<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/04/hello-world/"/>
    <url>/2023/07/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手写简易Netty_03——跟踪诊断</title>
    <link href="/2023/07/04/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-03%E2%80%94%E2%80%94%E8%B7%9F%E8%B8%AA%E8%AF%8A%E6%96%AD/"/>
    <url>/2023/07/04/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-03%E2%80%94%E2%80%94%E8%B7%9F%E8%B8%AA%E8%AF%8A%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="跟踪诊断-🕵️‍♂️"><a href="#跟踪诊断-🕵️‍♂️" class="headerlink" title="跟踪诊断 🕵️‍♂️"></a>跟踪诊断 🕵️‍♂️</h1><h2 id="完善线程名-💡"><a href="#完善线程名-💡" class="headerlink" title="完善线程名 💡"></a>完善线程名 💡</h2><p>在dubug模式中能够看见线程后面的数字，数字分别代表的意思是：</p><ul><li><p>2-1 boss group</p></li><li><p>3-1 worker group</p></li></ul><p>为了让我们在调试的时候更清晰的了解到具体是哪个线程，在serve中，添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeNioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultThreadFactory</span>(<span class="hljs-string">&quot;boss&quot;</span>));<br><span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultThreadFactory</span>(<span class="hljs-string">&quot;worker&quot;</span>));<br>serverBootstrap.group(boss, worker);<br></code></pre></td></tr></table></figure><p>打印的日志中便会出现线程名称。</p><h2 id="完善Handler名称-🛠️"><a href="#完善Handler名称-🛠️" class="headerlink" title="完善Handler名称 🛠️"></a>完善Handler名称 🛠️</h2><p>在debug模式下，能够看见handler的名称是默认使用类名，并且后面附带的数字意义是：</p><ul><li><p>$1 匿名内部类</p></li><li><p>#0 防止一个pipline中加入了多个handle</p></li></ul><p>通过给handler取名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pipeline.addLast(<span class="hljs-string">&quot;frameDecoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderFrameDecoder</span>());<br></code></pre></td></tr></table></figure><p>如果有名称就不需要$1 #0 之类的了。</p><h2 id="netty日志的原理及使用-📚"><a href="#netty日志的原理及使用-📚" class="headerlink" title="netty日志的原理及使用 📚"></a>netty日志的原理及使用 📚</h2><h3 id="netty日志框架原理-🤔"><a href="#netty日志框架原理-🤔" class="headerlink" title="netty日志框架原理 🤔"></a>netty日志框架原理 🤔</h3><p>通过对不同条件的判断可以使用SLF4J、Log4J、Log4J2、Jdk的log.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">codeprivate <span class="hljs-keyword">static</span> InternalLoggerFactory <span class="hljs-title function_">newDefaultFactory</span><span class="hljs-params">(String name)</span> &#123;<br>    Object f;<br>    <span class="hljs-keyword">try</span> &#123;<br>        f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4JLoggerFactory</span>(<span class="hljs-literal">true</span>);<br>        ((InternalLoggerFactory)f).newInstance(name).debug(<span class="hljs-string">&quot;Using SLF4J as the default logging framework&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var7) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            f = Log4JLoggerFactory.INSTANCE;<br>            ((InternalLoggerFactory)f).newInstance(name).debug(<span class="hljs-string">&quot;Using Log4J as the default logging framework&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var6) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                f = Log4J2LoggerFactory.INSTANCE;<br>                ((InternalLoggerFactory)f).newInstance(name).debug(<span class="hljs-string">&quot;Using Log4J2 as the default logging framework&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var5) &#123;<br>                f = JdkLoggerFactory.INSTANCE;<br>                ((InternalLoggerFactory)f).newInstance(name).debug(<span class="hljs-string">&quot;Using java.util.logging as the default logging framework&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (InternalLoggerFactory)f;<br>&#125;<br></code></pre></td></tr></table></figure><p>netty将所有log的依赖都增加进去了，但是在程序中还是看不见Slf4J是为什么？</p><p>因为在pom里面，使用了一个Optional参数标识了。导致了虽然项目依赖netty，但是项目中没有将slf4J下载下来。</p><h3 id="修改JDK-looger日志级别-⚙️"><a href="#修改JDK-looger日志级别-⚙️" class="headerlink" title="修改JDK looger日志级别 ⚙️"></a>修改JDK looger日志级别 ⚙️</h3><p>JDK自带的日志系统中的每一个日志记录器都可以有7个日志级别（LogLevel），从高级到低级，它们分别是：SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST。</p><p>进入JRE -&gt; lib 找到 logging.properties 文件</p><p>修改下面两行即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#日志级别</span><br><span class="hljs-attr">.level</span>= <span class="hljs-string">INFO</span><br><span class="hljs-comment">#控制台</span><br><span class="hljs-attr">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">INFO</span><br></code></pre></td></tr></table></figure><h3 id="使用slf4j-log4j示例-🔌"><a href="#使用slf4j-log4j示例-🔌" class="headerlink" title="使用slf4j + log4j示例 🔌"></a>使用slf4j + log4j示例 🔌</h3><p>在项目的pom文件中添加依赖即可，如果是添加log4j，那么需要添加相应的配置文件。</p><h3 id="衡量好logging-handler的位置和级别-⚖️"><a href="#衡量好logging-handler的位置和级别-⚖️" class="headerlink" title="衡量好logging handler的位置和级别 ⚖️"></a>衡量好logging handler的位置和级别 ⚖️</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO));<br></code></pre></td></tr></table></figure><p>核心是设置好级别 LogLevel的级别</p><p>通过设置LogginHandler的级别，可以打印出不同阶段的日志。</p><p>可以在childHandler方法内，按照需求设置相应的log</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
      <category>Tiny_Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>Java</tag>
      
      <tag>Tiny_Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写简易Netty_02——优化参数</title>
    <link href="/2023/07/04/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-02%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0/"/>
    <url>/2023/07/04/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-02%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="优化参数"><a href="#优化参数" class="headerlink" title="优化参数"></a>优化参数</h1><h2 id="Linux-系统参数"><a href="#Linux-系统参数" class="headerlink" title="Linux 系统参数"></a>Linux 系统参数</h2><p>例如：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_time</p><p>在进行 TCP 连接时，系统会为每个连接创建一个 socket 句柄，即文件句柄。然而，Linux 对每个进程所能打开的文件句柄数量有限制。当数量超出限制时，会出现 “Too many open file” 错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -n [xxx]<br></code></pre></td></tr></table></figure><p>注意：ulimit 命令修改的数值仅对当前登录用户的当前使用环境有效。系统重启或用户退出后，该设置会失效。因此，可以将其作为程序启动脚本的一部分，在程序启动前执行。</p><h2 id="Netty-支持的系统参数"><a href="#Netty-支持的系统参数" class="headerlink" title="Netty 支持的系统参数"></a>Netty 支持的系统参数</h2><ul><li>例如：serverBootstrap.option(ChannelOption.SO_BACKLOG, 1024); 使用 SO_ 开头</li><li>SocketChannel -&gt; .childOption</li><li>ServerSocketChannel -&gt; .option</li></ul><p>讨论 Netty 支持的系统参数 (ChannelOption.[XXX])：</p><ul><li>不考虑 UDP: IP_MULTICAST_TTL</li><li>不考虑 OIO 编程： <ul><li>ChannelOption SO_TIMEOUT &#x3D; (“SO_TIMEOUT”); </li><li>OIO 是阻塞编程，默认永远阻塞，因此需要控制阻塞时间</li></ul></li></ul><h3 id="SocketChannel-的-7-个参数"><a href="#SocketChannel-的-7-个参数" class="headerlink" title="SocketChannel 的 7 个参数"></a>SocketChannel 的 7 个参数</h3><table><thead><tr><th>Netty 系统相关参数</th><th>功能</th><th>默认值</th></tr></thead><tbody><tr><td>SO_SNDBUF</td><td>TCP 数据发送缓冲区大小</td><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_wmem: 4K[min, default, max] 动态调整</td></tr><tr><td>SO_RCVBUF</td><td>TCP 数据接受缓冲区大小</td><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_rmem: 4K</td></tr><tr><td>SO_KEEPALIVE</td><td>TCP 层 keepalive</td><td>默认关闭</td></tr><tr><td>SO_REUSEADDR</td><td>地址重用，解决 “Address already in use” 的常见场景：多网卡（IP）绑定相同端口；使关闭连接后的端口早些时候可供再次使用</td><td>默认不开启 澄清：不是让 TCP 绑定完全相同 IP + Port 来重复启动</td></tr><tr><td>SO_LINGER</td><td>关闭 Socket 的延迟时间，默认禁用该功能，socket.close() 方法立即返回</td><td>默认不开启</td></tr><tr><td>IP_TOS</td><td>设置 IP 头部的 Type-of-Service 字段，用于描述 IP 包的优先级和 QoS 选项。例如倾向于延时还是吞吐量？</td><td>1000 - minimize delay<br>0100 - maximize throughput <br/>0010 - maximize reliability <br/>0001 - minimize monetary cost <br/>0000 - normal service （默认值） <br/>socket 选项的值是一个提示。实现可以忽略该值，或者忽略特定值</td></tr><tr><td>TCP_NODELAY</td><td>设置是否启用 Nagle 算法：使用该算法将小的碎片数据连接成更大的报文以提高发送效率</td><td>False 如果需要发送一些较小的报文，则需要禁用该算法</td></tr></tbody></table><h3 id="ServerSocketChannel-的-3-个参数"><a href="#ServerSocketChannel-的-3-个参数" class="headerlink" title="ServerSocketChannel 的 3 个参数"></a>ServerSocketChannel 的 3 个参数</h3><table><thead><tr><th>Netty 系统相关参数</th><th>功能</th><th>默认值</th></tr></thead><tbody><tr><td>SO_RCVBUF 接收数据缓冲区</td><td>为 Accept 创建的 socket channel 设置 SO_RCVBUF，”设置从此 ServerSocket 接受的套接字的 SO_RCVBUF 选项的默认建议值”</td><td>为什么有 SO_RCVBUF 而没有 SO_SNDBUF？我们可以在设置 sndbuf 之后再发送数据，这段时间可以自行控制</td></tr><tr><td>SO_REUSEADDR</td><td>是否可以重用端口</td><td>false</td></tr><tr><td>SO_BACKLOG</td><td>最大的等待连接数量</td><td>Netty 在 Linux 下获取的值（io.netty.util.NetUtil）：<br>1. 首先尝试：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxcon <br>2. 然后尝试：sysctl <br>3. 如果都没有取到，使用默认值：128 <br>使用方式： <code>javaChannel().bind(localAddress, config.getBacklog());</code></td></tr></tbody></table><h3 id="参数调整要点"><a href="#参数调整要点" class="headerlink" title="参数调整要点"></a>参数调整要点</h3><ul><li>option&#x2F;childOption 区分不清：不会报错，但不会生效。</li><li>不了解的参数不要随意修改，避免过早优化。</li><li>最好可配置（动态配置更佳）。</li></ul><h3 id="需要调整的参数"><a href="#需要调整的参数" class="headerlink" title="需要调整的参数"></a>需要调整的参数</h3><p>最大打开文件数 • TCP_NODELAY • SO_BACKLOG • SO_REUSEADDR（视情况处理）</p><p>将 SO_BACKLOG 的默认值 128 调整为 1024</p><h3 id="具体调整"><a href="#具体调整" class="headerlink" title="具体调整"></a>具体调整</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Server.java<br><span class="hljs-comment">// 系统参数</span><br>serverBootstrap.childOption(NioChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>);<br>serverBootstrap.option(NioChannelOption.SO_BACKLOG, <span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure><h2 id="Netty核心参数"><a href="#Netty核心参数" class="headerlink" title="Netty核心参数"></a>Netty核心参数</h2><p>ChannelOption</p><ul><li>childOption(ChannelOption.[XXX], [YYY])</li><li>option(ChannelOption.[XXX], [YYY])</li></ul><p>System property</p><ul><li>Dio.netty.[XXX] &#x3D; [YYY]</li></ul><h3 id="ChannelOption（非系统相关：共11个）"><a href="#ChannelOption（非系统相关：共11个）" class="headerlink" title="ChannelOption（非系统相关：共11个）"></a>ChannelOption（非系统相关：共11个）</h3><table><thead><tr><th>Netty 系统相关参数</th><th>功能</th><th>默认值</th></tr></thead><tbody><tr><td>WRITE_BUFFER_WATER_MARK</td><td>高低水位线、间接防止写数据 OOM</td><td>32k → 64k 😮，为什么不大？每个连接都64k的话，那就太大了。</td></tr><tr><td>CONNECT_TIMEOUT_MILLIS</td><td>客户端连接服务器最大允许时间</td><td>30s ⏱️</td></tr><tr><td>MAX_MESSAGES_PER_READ</td><td>最大允许“连续”读次数</td><td>16次</td></tr><tr><td>WRITE_SPIN_COUNT</td><td>最大允许“连读”写次数</td><td>16次</td></tr><tr><td>ALLOCATOR ByteBuf</td><td>分配器</td><td>ByteBufAllocator.DEFAULT：大多池化、堆外</td></tr><tr><td>RCVBUF_ALLOCATOR</td><td>数据接收 ByteBuf 分配大小计算器（计算是否达到水位线） + 读次数控制器</td><td>AdaptiveRecvByteBufAllocator</td></tr><tr><td>AUTO_READ</td><td>是否监听“读事件”</td><td>默认：监听“读”事件： 设置此标记的方法也触发注册或移除读事件的监听</td></tr><tr><td>AUTO_CLOSE</td><td>“写数据”失败，是否关闭连接</td><td>默认打开，因为不关闭，下次还写，还是失败怎么办！</td></tr><tr><td>MESSAGE_SIZE_ESTIMATOR</td><td>数据（ByteBuf、FileRegion等）大小计算器</td><td>DefaultMessageSizeEstimator.DEFAULT 例如计算 ByteBuf: byteBuf.readableBytes()</td></tr><tr><td>SINGLE_EVENTEXECUTOR_PER _GROUP</td><td>当增加一个 handler 且指定 EventExecutorGroup 时：决定这个 handler 是否只用 EventExecutorGroup 中的一个固定的 EventExecutor （取决于next()实现）</td><td>默认：true: 这个 handler 不管是否共享，绑定上唯一一个 event executor.所以小名“pinEventExecutor” 没有指定 EventExecutorGroup，复用 channel 的 NioEventLoop</td></tr><tr><td>ALLOW_HALF_CLOSURE</td><td>关闭连接时，允许半关。 <a href="https://issues.jboss.org/browse/NETTY-236">https://issues.jboss.org/browse/NETTY-236</a></td><td>默认：不允许半关，如果允许，处理变成： shutdownInput(); pipeline.fireUserEventTriggered(ChannelInputShutd ownEvent.INSTANCE);</td></tr></tbody></table><h3 id="ALLOCATOR-与-RCVBUF-ALLOCATOR"><a href="#ALLOCATOR-与-RCVBUF-ALLOCATOR" class="headerlink" title="ALLOCATOR 与 RCVBUF_ALLOCATOR"></a>ALLOCATOR 与 RCVBUF_ALLOCATOR</h3><p><strong>功能关联：</strong></p><ul><li>ALLOCATOR 负责 ByteBuf 怎么分配（例如：从哪里分配），</li><li>RCVBUF_ALLOCATOR 负责计算为接收数据接分配多少 ByteBuf： 例如，AdaptiveRecvByteBufAllocator 有两大功能：<ul><li>动态计算下一次分配 bytebuf 的大小：guess()；</li><li>判断是否可以继续读：continueReading()</li></ul></li></ul><p><strong>代码关联：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.channel.AdaptiveRecvByteBufAllocator.<span class="hljs-type">HandleImpl</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> AdaptiveRecvByteBufAllocator.newHandle(); <br><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> handle.allocate(ByteBufAllocator)<br></code></pre></td></tr></table></figure><p>其中： allocate的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf <span class="hljs-title function_">allocate</span><span class="hljs-params">(ByteBufAllocator alloc)</span> &#123; <span class="hljs-keyword">return</span> alloc.ioBuffer(guess()); &#125;<br></code></pre></td></tr></table></figure><h3 id="在TinyNetty中调整"><a href="#在TinyNetty中调整" class="headerlink" title="在TinyNetty中调整"></a>在TinyNetty中调整</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Client.java<br><span class="hljs-comment">//调整连接超时</span><br>bootstrap.option(NioChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h2 id="三个让费脑的参数"><a href="#三个让费脑的参数" class="headerlink" title="三个让费脑的参数"></a>三个让费脑的参数</h2><p>大多数情况下都可以不予考虑</p><h3 id="地址重用：SO-REUSEADDR-🔄"><a href="#地址重用：SO-REUSEADDR-🔄" class="headerlink" title="地址重用：SO_REUSEADDR 🔄"></a>地址重用：SO_REUSEADDR 🔄</h3><p><code>SO_REUSEADDR</code>是一个套接字选项，用于控制套接字地址的重用。在TCP连接关闭后，操作系统会在一段时间内保持该套接字地址（IP地址+端口号）的占用状态，以确保任何延迟到达的数据能够正确传递到应用程序。</p><p>在TCP连接关闭流程中，客户端向服务器发送ack。此时，客户端会等待2MSL，以确保服务器正确接收到该ack。如果服务器未收到ack，则会发送超时重传的FIN消息，客户端将再次发送ack。如果服务器接收到了ack，则不会发送任何消息。</p><p><img src="/img/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-02%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0/image-20230624160306498.png" alt="image-20230624160306498"></p><p>因此，客户端需要等待的时间为：</p><p><strong>去向ack消息最大存活时间（MSL）+ 来向FIN消息最大存活时间（MSL） &#x3D; 2MSL</strong></p><p>通常为60秒，但在网络质量较好的情况下，可以缩短到1秒。相信1秒的TIME_WAIT足够了。</p><p>当你将 <code>SO_REUSEADDR</code> 选项设置为 <code>true</code> 时，表示允许在使用过程中关闭的套接字被重新绑定到同一个地址。这样，你就可以立即重新绑定相同的地址，而无需等待保持期结束。这在某些特定的应用场景中非常有用，比如服务器需要快速重启或频繁绑定相同的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.option(ChannelOption.SO_REUSEADDR, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h3 id="SO-LINGER：关闭时间-🌅"><a href="#SO-LINGER：关闭时间-🌅" class="headerlink" title="SO_LINGER：关闭时间 🌅"></a>SO_LINGER：关闭时间 🌅</h3><p><code>SO_LINGER</code>定义了关闭套接字时是否立即关闭或等待一段时间。具体而言，<code>SO_LINGER</code>选项控制操作系统在关闭套接字时的行为。</p><p>默认情况下，当关闭套接字时，操作系统会尝试发送任何待发送的数据，并立即关闭套接字。这意味着，如果还有未发送的数据，它们可能会丢失。</p><p>通过设置<code>SO_LINGER</code>选项，你可以改变这种默认行为。当将<code>SO_LINGER</code>设置为非零的超时值时，关闭套接字的行为将发生变化。具体而言，当你关闭套接字时，操作系统会尝试发送所有待发送的数据，并等待指定的超时时间。</p><p>需要注意的是，<code>SO_LINGER</code>选项可能会影响行为和延迟。如果存在未发送完的数据，等待超时时间可能会导致套接字关闭的延迟。因此，在使用<code>SO_LINGER</code>选项时，你需要根据自己的需求仔细评估和权衡。</p><p>另外，将<code>timeout</code>设置为0表示关闭套接字时立即丢弃未发送的数据，并立即关闭套接字。</p><p><img src="/img/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-02%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0/image-20230624161738285.png" alt="image-20230624161738285"></p><h4 id="如何判断是否需要设置？"><a href="#如何判断是否需要设置？" class="headerlink" title="如何判断是否需要设置？"></a>如何判断是否需要设置？</h4><ol><li>重要数据的完整性</li><li>如果你的应用程序需要在关闭套接字之前执行特定的清理操作或发送最后的消息，那么设置<code>SO_LINGER</code>可以提供可控的关闭行为。</li><li>延迟和性能：需要注意的是，设置<code>SO_LINGER</code>可能会导致套接字关闭的延迟。如果你的应用程序对延迟非常敏感，或需要快速释放资源而快速关闭套接字，那么设置<code>SO_LINGER</code>可能不是一个好的选择。</li></ol><h3 id="ALLOW-HALF-CLOSURE：半关闭-🤝"><a href="#ALLOW-HALF-CLOSURE：半关闭-🤝" class="headerlink" title="ALLOW_HALF_CLOSURE：半关闭 🤝"></a>ALLOW_HALF_CLOSURE：半关闭 🤝</h3><p><code>ALLOW_HALF_CLOSURE</code>是Netty中的一个选项，用于控制是否允许半关闭（Half Closure）操作。半关闭是指在一个TCP连接中，一方关闭了输出流（发送方），但保持输入流（接收方）仍然打开。</p><p>默认情况下，Netty不允许半关闭操作。这意味着，当一方关闭输出流时，另一方将接收到连接关闭的事件，从而关闭整个连接。这种行为符合TCP协议的规范，因为一方关闭输出流意味着不再发送数据，连接可以被认为是完全关闭了。</p><p>然而，在某些情况下，你可能希望允许半关闭操作。例如，如果你的应用程序中的一方关闭了输出流，但仍希望接收另一方发送的数据，那么你可以使用<code>ALLOW_HALF_CLOSURE</code>选项。</p><p>需要注意的是，在启用半关闭后，在处理连接关闭事件时要特别小心。你可能需要检查连接的状态，以确定是完全关闭连接还是仅关闭输出流。</p><p><img src="/img/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-02%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0/image-20230624161951034.png" alt="image-20230624161951034"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline().option(ChannelOption.ALLOW_HALF_CLOSURE, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
      <category>Tiny_Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>Java</tag>
      
      <tag>Tiny_Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写简易Netty_01——搭建项目</title>
    <link href="/2023/07/03/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty_01%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/07/03/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty_01%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="基本步骤-🚀"><a href="#基本步骤-🚀" class="headerlink" title="基本步骤 🚀"></a>基本步骤 🚀</h1><p><img src="/img/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-01/image-20230622192508774-16883882639981.png" alt="image-20230622192508774"></p><p><img src="/img/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-01/image-20230622192533845-16883882639992.png" alt="image-20230622192533845"></p><h1 id="案例介绍和设计数据结构-💡"><a href="#案例介绍和设计数据结构-💡" class="headerlink" title="案例介绍和设计数据结构 💡"></a>案例介绍和设计数据结构 💡</h1><p>我们将编写一个服务器（server）和客户端（client），以支持网络通信，包括请求和响应。同时设计了两个接口，用于授权和保持连接的请求和响应。</p><p><img src="/img/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-01/image-20230622193251995.png" alt="image-20230622193251995"></p><p>消息体（body）使用 JSON 格式，表示操作（operation）的请求和响应。</p><p>消息头（header）中有多种操作类型（OP），需要定义不同的操作代码（OP_Code）。版本（version）用于表示版本号和处理兼容性。流ID（streamID）用作唯一标识符。</p><p>长度字段表示消息的长度，用于表示一个帧（frame）。</p><p><img src="/img/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93Netty-01/image-20230622193446330.png" alt="image-20230622193446330"></p><p>我们不深入业务逻辑，只关注思想和流程。</p><h1 id="常见易错点-🔍"><a href="#常见易错点-🔍" class="headerlink" title="常见易错点 🔍"></a>常见易错点 🔍</h1><ul><li><p><code>LengthFieldBasedFrameDecoder</code> 中未正确设置 <code>initialBytesToStrip</code>。如果未设置，解决粘包和半包问题时，仍然会携带长度字段。</p></li><li><p><code>ChannelHandler</code> 的顺序不正确：</p><ul><li>编写顺序应按照1~5进行编写，但执行顺序是 1 -&gt; 4 -&gt; 2 -&gt; 3 -&gt; 5。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderFrameDecoder</span>());<br><span class="hljs-number">2.</span> pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderFrameEncoder</span>());<br><span class="hljs-number">3.</span> pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderProtocolEncoder</span>());<br><span class="hljs-number">4.</span> pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderProtocolDecoder</span>());<br><span class="hljs-number">5.</span> pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderServerProcessHandler</span>());<br></code></pre></td></tr></table></figure></li><li><p><code>ChannelHandler</code> 共享与非共享问题（线程安全）：</p><ul><li>例如，<code>pipeline.addLast(new LoggingHandler(LogLevel.INFO));</code> 中的 <code>LoggingHandler</code> 是可以共享的，因此不需要在每个 <code>ChannelHandler</code> 中创建。但在多线程环境中，不应该共享的 <code>Handler</code> 却被共享了，就会出现线程问题。</li></ul></li><li><p>分配 <code>ByteBuf</code>：应使用 <code>ByteBufAllocator.DEFAULT</code> 等分配器，而不是使用 <code>ChannelHandlerContext.alloc()</code>。在分配 <code>ByteBuf</code> 时，无论是堆外内存还是堆内内存，都可以使用。如果切换了实现方式，那么使用了 <code>ByteBufAllocator.DEFAULT</code> 的地方，实现方式不一致，就会出现问题。</p></li><li><p>未考虑释放 <code>ByteBuf</code>：</p><ul><li>即使不接收消息，仍然应调用 <code>release</code> 方法进行释放。</li></ul></li><li><p>错误地认为 <code>ChannelHandlerContext.write(msg)</code> 就会将数据写出：</p><ul><li><code>write</code> 方法只是将消息添加到队列中。</li><li>该方法仅在当前 <code>pipeline</code> 的位置寻找下一个符合条件的 <code>handler</code>。</li></ul></li><li><p>误用 <code>ChannelHandlerContext.channel().writeAndFlush(msg)</code>：</p><ul><li>此消息发送会使整个 <code>pipeline</code> 重新执行一遍。如果在中间的处理器执行了该方法，将会从头开始执行，导致死循环。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
      <category>Tiny_Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>Java</tag>
      
      <tag>Tiny_Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty常见问题</title>
    <link href="/2023/06/21/Netty%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/06/21/Netty%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty常见问题"><a href="#Netty常见问题" class="headerlink" title="Netty常见问题"></a>Netty常见问题</h1><h3 id="1-Could-not-find-artifact-io-netty-netty-tcnative-jar-windows-x86-32-2-0-25-Final-in-centra"><a href="#1-Could-not-find-artifact-io-netty-netty-tcnative-jar-windows-x86-32-2-0-25-Final-in-centra" class="headerlink" title="1. Could not find artifact io.netty:netty-tcnative:jar:windows-x86_32:2.0.25.Final in centra"></a>1. Could not find artifact io.netty:netty-tcnative:jar:windows-x86_32:2.0.25.Final in centra</h3><p>netty编译时，如果是32位系统，则会报错”Could not find artifact io.netty:netty-tcnative:jar:windows-x86_32:2.0.25.Final in centra“。</p><p><img src="/img/Netty%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20230614154337227.png" alt="image-20230614154337227"></p><p>在netty-parent模块下pom.xml文件第306行开始，能够看见tcnative.classifier。其中，classifier表示是一个二级分类（区分不同的jdk，版本号等）</p><p>在这里是想要通过os.detected.classifier获取一个classifier，以达到获取系统版本号的的目的。</p><p><strong>解决方法：</strong></p><ol><li>将JDK、IDEA、操作系统这三者都更改为64位，这样能够保证下载的是64为jar包</li><li>直接指定jar包的版本为32位。</li></ol><h3 id="2-java-程序包io-netty-util-collection不存在"><a href="#2-java-程序包io-netty-util-collection不存在" class="headerlink" title="2.java:程序包io.netty.util.collection不存在"></a>2.java:程序包io.netty.util.collection不存在</h3><p><img src="/img/Netty%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20230614161752830.png" alt="image-20230614161752830"></p><p>在netty-common模块内，会通过模板和脚本（templates和script包）生成java文件。因此也能在pom.xml文件中找到驱动脚本执行的groovy包，设置是在编译的时候执行codegen.groovy文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>generate-collections<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>execute<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>$&#123;project.basedir&#125;/src/main/script/codegen.groovy<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解决方案</strong>：但是有时候不会自动编译，可以自己直接执行编译命令，也可也在idea中点击maven compile执行。代码将会生成到target里面。</p><p><img src="/img/Netty%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20230614162645764.png" alt="image-20230614162645764"></p><p><img src="/img/Netty%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20230617222109130.png" alt="image-20230617222109130"></p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极客时间《netty源码剖析与实战》学习笔记1</title>
    <link href="/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h2 id="Netty是什么"><a href="#Netty是什么" class="headerlink" title="Netty是什么"></a>Netty是什么</h2><p>netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端</p><p><a href="https://link.zhihu.com/?target=https://netty.io/">官网 netty.io</a></p><p>netty架构</p><p><img src="https://pic3.zhimg.com/80/v2-29b44a34e39f5dfff4bcf13a61d9bad6_720w.webp" alt="img"></p><h2 id="和JDK-NIO的对比"><a href="#和JDK-NIO的对比" class="headerlink" title="和JDK NIO的对比"></a>和JDK NIO的对比</h2><p>Netty做的更多：</p><ul><li>支持常用应用层协议；</li><li>解决传输问题：粘包、半包现象；</li><li>支持流量整形； 完善的断连、Idle异常处理等。</li><li>API更友好更强大： 例如bytebuffer -&gt; netty bytebuf threadlocal -&gt; fastthreadlocal 隔离变化、屏蔽细节 隔离jdk nio实现细节： nio -&gt; nio2(aio)</li><li>规避JDK NIO BUG：</li></ul><p><img src="https://pic2.zhimg.com/80/v2-e979f9b54145122a8b3513aa6f34af35_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-b562cb059d9a83a33e6a9bf355f44b89_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-738b0a68dfc6d012f9e6b68bdf21d1ea_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-d464beb2f6b5ad7e6c32dc584ced204d_720w.webp" alt="img"></p><h3 id="NIO缺点"><a href="#NIO缺点" class="headerlink" title="NIO缺点"></a>NIO缺点</h3><ul><li>api繁杂，</li><li>需要熟悉java多线程，网络编程</li><li>epoll bug会导致selector空轮询，最终导致cpu 100%</li></ul><h3 id="netty优点"><a href="#netty优点" class="headerlink" title="netty优点"></a>netty优点</h3><ul><li>api简单</li><li>支持多种协议</li><li>性能高</li><li>社区活跃</li></ul><h2 id="Netty竞品"><a href="#Netty竞品" class="headerlink" title="Netty竞品"></a>Netty竞品</h2><ul><li>apache mina（同一作者，推荐Netty）</li></ul><p><img src="https://pic1.zhimg.com/80/v2-d0c37ab03af208660b4674387b48fea8_720w.webp" alt="img"></p><ul><li>sun grizzly(用得少、文档少、更新少)</li><li>apple swift nio、ACE（其他语言，不考虑）</li><li>Cindy（生命周期不长）</li><li>tomcat、jetty（还没有独立出来）</li></ul><h2 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h2><ul><li>2004年6月 Netty2发布</li><li>2008年10月Netty3发布</li><li>2013年7月Netty4发布</li><li>2013年12月发布Netty 5.0.0 alpha</li><li>2015年11月废弃5.0.0（废弃原因： 复杂、没有证明明显性能优势、维护不过来，主要维护3.10.X、4.0.X、4.1.X）</li></ul><h2 id="典型使用项目"><a href="#典型使用项目" class="headerlink" title="典型使用项目"></a>典型使用项目</h2><ul><li>数据库： Cassandra</li><li>大数据处理：Spark、Hadoop</li><li>MQ: RocketMQ</li><li>搜索：Elasticsearch</li><li>框架：gRPC、apache dubbo、Spring5</li><li>分布式协调器： ZooKeeper</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
      <category>极客时间</category>
      
      <category>Netty源码剖析与实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>Java</tag>
      
      <tag>极客时间</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极客时间《netty源码剖析与实战》学习笔记2</title>
    <link href="/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h2 id="1-如何切换io模式"><a href="#1-如何切换io模式" class="headerlink" title="1 如何切换io模式"></a><strong>1 如何切换io模式</strong></h2><p>在io.netty.example.echo.EchoServer类中，找到</p><p><img src="https://pic2.zhimg.com/80/v2-3dae64aaab1be8932dfe700454d3c2ad_720w.webp" alt="img"></p><ol><li>OioEventLoopGroup()，将bossGroup和workerGroup的示例切换成其他IO，例如 <code>new OioEventLoopGroup()</code> ，以切换不同的开发模式。<br>&#x2F;&#x2F; 更改这两行，换成想要的IO<br>EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();<br>EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</li><li>在ServerBootstrap中切换channel。切换不同的IO模式</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">ServerBootstrap b = new ServerBootstrap();<br>b.group(bossGroup, workerGroup)<br> .channel(NioServerSocketChannel.class)<br></code></pre></td></tr></table></figure><p>三行解决切换。</p><h3 id="channel方法源码解析"><a href="#channel方法源码解析" class="headerlink" title="channel方法源码解析"></a><strong>channel方法源码解析</strong></h3><p>在channel方法中，是一个反射工厂的实现</p><p><img src="https://pic4.zhimg.com/80/v2-ef8a3ad3cbf910f9122e7d2f1f6d92b3_720w.webp" alt="img"></p><p>下图为ReflectiveChannelFactory的具体实现，这个类实现了ChannelFactory<T>。</p><p>在构造方法中的实参是一个泛型，我们将一个NioServerSocketChannel.class传入，则会获取这个类的无参构造器，然后再newChannel()方法中通过反射创建不同的channel类型。实现IO模式的切换。<strong>泛型+反射+工厂模式实现IO切换</strong></p><p><img src="https://pic1.zhimg.com/80/v2-ab48ac6df1a8501308ced5d8bba7b584_720w.webp" alt="img"></p><h3 id="不需要切换客户端对应的Nio"><a href="#不需要切换客户端对应的Nio" class="headerlink" title="不需要切换客户端对应的Nio"></a><strong>不需要切换客户端对应的Nio</strong></h3><p>在服务器开发中，并不需要切换客户端对应的NioSocketChannel.</p><p>在doReadMessage方法中，实现了accept方法，通过accept方法创建出一个socketChannel。</p><p><img src="https://pic4.zhimg.com/80/v2-c39e67cb5cacca1a83abf6078d83f6c7_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-f3205341049f20fd126117b211978c34_720w.webp" alt="img"></p><h3 id="NioEventLoop是什么？"><a href="#NioEventLoop是什么？" class="headerlink" title="NioEventLoop是什么？"></a><strong>NioEventLoop是什么？</strong></h3><p>NioEventLoop继承SingleThreadEventLoop。将Channel注册到Selector，实现事件循环多路复用。在run方法中，写一个死循环实现selector，负责监听、处理事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//死循环监听、处理事件</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                    <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    select(wakenUp.getAndSet(<span class="hljs-literal">false</span>));<br>                    <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>                        selector.wakeup();<br>                    &#125;<br>                    <span class="hljs-comment">// fall through</span><br>                <span class="hljs-keyword">default</span>:<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-comment">// If we receive an IOException here its because the Selector is messed up. Let&#x27;s rebuild</span><br>                <span class="hljs-comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span><br>                rebuildSelector0();<br>                handleLoopException(e);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            cancelledKeys = <span class="hljs-number">0</span>;<br>            needsToSelectAgain = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ioRatio</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.ioRatio;<br>            <span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    runAllTasks();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioStartTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioTime</span> <span class="hljs-operator">=</span> System.nanoTime() - ioStartTime;<br>                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>        <span class="hljs-comment">// Always handle shutdown even if the loop processing threw an exception.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (isShuttingDown()) &#123;<br>                closeAll();<br>                <span class="hljs-keyword">if</span> (confirmShutdown()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Netty如何支持三种Reactor"><a href="#2-Netty如何支持三种Reactor" class="headerlink" title="2.Netty如何支持三种Reactor"></a><strong>2.Netty如何支持三种Reactor</strong></h2><p>在NIO模式下，所对应的开发模式就是reactor。</p><h3 id="三种reactor"><a href="#三种reactor" class="headerlink" title="三种reactor"></a><strong>三种reactor</strong></h3><ol><li>单线程，一个线程去处理全部事件，容易阻塞。线程挂了系统也挂了。</li></ol><p><img src="https://pic2.zhimg.com/80/v2-479693a68f46a13d73c5e4b38d5a9cb9_720w.webp" alt="img"></p><p>\2. 多线程，将decode compute encode放入线程池进行处理。</p><p><img src="https://pic3.zhimg.com/80/v2-a4f714b10dc66042cbe05597c1d01762_720w.webp" alt="img"></p><p>\3. 主从多线程模式，在服务器开发中，acceptor专门放到一个reactor中。</p><p><img src="https://pic1.zhimg.com/80/v2-b92ac3390dba142dd5c07e496378f8dc_720w.webp" alt="img"></p><h3 id="reactor核心流程"><a href="#reactor核心流程" class="headerlink" title="reactor核心流程"></a><strong>reactor核心流程</strong></h3><p>注册事件-&gt;扫描是否有事件发生-&gt;事件发生后进行处理</p><p><img src="https://pic2.zhimg.com/80/v2-184414c85fcbae94d5084c30f6d676d9_720w.webp" alt="img"></p><h3 id="不同的reactor如何去实现"><a href="#不同的reactor如何去实现" class="headerlink" title="不同的reactor如何去实现"></a><strong>不同的reactor如何去实现</strong></h3><table><thead><tr><th>Reactor 单线程模式</th><th>EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup(1); ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap(); serverBootstrap.group(eventGroup);</th></tr></thead><tbody><tr><td>非主从 Reactor 多线程模式</td><td>EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup(); ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap(); serverBootstrap.group(eventGroup); &#x2F;&#x2F;默认根据cpu的核心数进行new线程。</td></tr><tr><td>主从 Reactor 多线程模式</td><td>EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(); EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup(); ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup);</td></tr></tbody></table><h2 id="3-netty对reactor的常见疑问"><a href="#3-netty对reactor的常见疑问" class="headerlink" title="3.netty对reactor的常见疑问"></a><strong>3.netty对reactor的常见疑问</strong></h2><h3 id="3-1-Netty-如何支持主从-Reactor-模式的？"><a href="#3-1-Netty-如何支持主从-Reactor-模式的？" class="headerlink" title="3.1 Netty 如何支持主从 Reactor 模式的？"></a><strong>3.1 Netty 如何支持主从 Reactor 模式的？</strong></h3><p>在EchoServer中，bossGroup就是main reactor。 workerGroup就是sub Reactor。</p><p><img src="https://pic2.zhimg.com/80/v2-af2d850c62d844f90c87ab40c4f088f5_720w.webp" alt="img"></p><p>serverSocketChannel绑定到bossGroup中，那么serverSocketChannel就会创建childChannel并且绑定到workerGroup中。把两种socketchanner绑定到两个不同的group中，用于支持主从reactor模式。</p><h3 id="3-2-为什么说-Netty-的-main-reactor-大多并不能用到一个线程组，只能线程组里面的一个？"><a href="#3-2-为什么说-Netty-的-main-reactor-大多并不能用到一个线程组，只能线程组里面的一个？" class="headerlink" title="3.2 为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个？"></a><strong>3.2 为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个？</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-11d4193a99916879a4bb46aa7de1ef78_720w.webp" alt="img"></p><p>io.netty.bootstrap.AbstractBootstrap#doBind（）方法里面初始化bossgroup，doBind()方法绑定一个地址和端口，把服务器给启动起来。对于服务器来说，我们一般只会绑定一个地址和一个端口，所以我们只会调用一次线程组的线程。</p><h3 id="3-3-Netty-给-Channel-分配-NIO-event-loop-的规则是什么"><a href="#3-3-Netty-给-Channel-分配-NIO-event-loop-的规则是什么" class="headerlink" title="3.3 Netty 给 Channel 分配 NIO event loop 的规则是什么"></a><strong>3.3 Netty 给 Channel 分配 NIO event loop 的规则是什么</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel) <br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel)</span> &#123;<br>        <span class="hljs-keyword">return</span> next().register(channel);<br>    &#125;<br><br><span class="hljs-comment">//根据待绑定的executor是否是2的幂次方，做出不同的选择</span><br>io.netty.util.concurrent.DefaultEventExecutorChooserFactory#newChooser<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutorChooser <span class="hljs-title function_">newChooser</span><span class="hljs-params">(EventExecutor[] executors)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isPowerOfTwo(executors.length)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span>(executors);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericEventExecutorChooser</span>(executors);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果是2的幂次方，会有一个内部类，实现一个取模运算提升效率。</p><p>注意：这里的下标要保证线程安全，所以使用AtomicInteger的自增。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<br><br>    PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;<br>        <span class="hljs-built_in">this</span>.executors = executors;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//executors总数必须是2的幂次方（2，4，8...等）才会用,&amp;运算效率更高,同时当idx累加成最大值之后，相比较通用的方式（GenericEventExecutorChooser），更公平</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不是二的倍数，使用默认方法，递增-&gt;取模-&gt;取绝对值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<br><br>    GenericEventExecutorChooser(EventExecutor[] executors) &#123;<br>        <span class="hljs-built_in">this</span>.executors = executors;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//递增、取模，取正值，不然可能是负数，另外：有个非常小的缺点，当idx累加成最大值后，有短暂的不公平：</span><br>        <span class="hljs-comment">//1，2，3，4，5，6，7，0，7（注意这里不是1，而是7，然而往前的第二个也是7，所以不够公平），6，5</span><br>        <span class="hljs-keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-通用模式的-NIO-实现多路复用器是怎么跨平台的"><a href="#3-4-通用模式的-NIO-实现多路复用器是怎么跨平台的" class="headerlink" title="3.4 通用模式的 NIO 实现多路复用器是怎么跨平台的"></a><strong>3.4 通用模式的 NIO 实现多路复用器是怎么跨平台的</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.channel.nio.NioEventLoopGroup#NioEventLoopGroup(<span class="hljs-type">int</span>, java.util.concurrent.Executor)   <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor)</span> &#123;<br>        <span class="hljs-comment">//默认selector,最终实现类似：https://github.com/frohoff/jdk8u-jdk/blob/master/src/macosx/classes/sun/nio/ch/DefaultSelectorProvider.java</span><br>        <span class="hljs-comment">//basic flow: 1 java.nio.channels.spi.SelectorProvider 2 META-INF/services 3 default</span><br>        <span class="hljs-built_in">this</span>(nThreads, executor, SelectorProvider.provider());<br>    &#125;<br><br>java.nio.channels.spi.SelectorProvider#provider<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SelectorProvider <span class="hljs-title function_">provider</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">if</span> (provider != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> provider;<br>            <span class="hljs-keyword">return</span> AccessController.doPrivileged(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;SelectorProvider&gt;() &#123;<br>                    <span class="hljs-keyword">public</span> SelectorProvider <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                           ........<br>                            provider = sun.nio.ch.DefaultSelectorProvider.create(); <span class="hljs-comment">//调用不同平台下的创建方法进行创建</span><br>                            <span class="hljs-keyword">return</span> provider;<br>                        &#125;<br>                    &#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SelectorProvider <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KQueueSelectorProvider</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4-TCP粘包、半包"><a href="#4-TCP粘包、半包" class="headerlink" title="4.TCP粘包、半包"></a><strong>4.TCP粘包、半包</strong></h2><h3 id="什么是粘包和半包？"><a href="#什么是粘包和半包？" class="headerlink" title="什么是粘包和半包？"></a><strong>什么是粘包和半包？</strong></h3><p>abc \n def -&gt; a bcd\nef</p><p>想要发送的是两段信息分别是abc和def中间由\n分隔。在传输过后，先接受到a，再接收到bcd\nef。那么先接收到的a就是半包（没接收完整），后面接收到的 “bcd \n ef”，就是粘包。</p><h3 id="为什么TCP应用中会出现粘包和半包现象？"><a href="#为什么TCP应用中会出现粘包和半包现象？" class="headerlink" title="为什么TCP应用中会出现粘包和半包现象？"></a><strong>为什么TCP应用中会出现粘包和半包现象？</strong></h3><h3 id="粘包的主要原因："><a href="#粘包的主要原因：" class="headerlink" title="粘包的主要原因："></a><strong>粘包的主要原因：</strong></h3><ul><li>发送方每次写入数据 &lt; 套接字缓冲区大小</li><li>接收方读取套接字缓冲区不够及时</li></ul><h3 id="半包："><a href="#半包：" class="headerlink" title="半包："></a><strong>半包：</strong></h3><ul><li>发送方写入数据 &gt; 套接字缓冲区大小</li><li>发送的数据大于协议的MTU（最大传输单元），必须拆包</li></ul><h3 id="从收发传输的角度看："><a href="#从收发传输的角度看：" class="headerlink" title="从收发传输的角度看："></a><strong>从收发传输的角度看：</strong></h3><ul><li>一个发送可能被多次接收，多个发送可能被一次接收（缓冲区）</li><li>一个发送占用了多个传输包，多个发送可能占用一个传输包</li></ul><p><strong>问题的根本原因：TCP没有消息边界</strong></p><h3 id="解决沾包和半包问题的几种常用方法"><a href="#解决沾包和半包问题的几种常用方法" class="headerlink" title="解决沾包和半包问题的几种常用方法"></a><strong>解决沾包和半包问题的几种常用方法</strong></h3><p><strong>解决手段：找出消息边界</strong></p><p><img src="https://pic4.zhimg.com/80/v2-92af5693be90621266c531186492a22b_720w.webp" alt="img"></p><h3 id="Netty对三种常用封帧方式的支持"><a href="#Netty对三种常用封帧方式的支持" class="headerlink" title="Netty对三种常用封帧方式的支持"></a><strong>Netty对三种常用封帧方式的支持</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-1576feaecc2bfe3cadb44432d0d3c639_720w.webp" alt="img"></p><h2 id="解读Netty处理粘包、半包的源码"><a href="#解读Netty处理粘包、半包的源码" class="headerlink" title="解读Netty处理粘包、半包的源码"></a><strong>解读Netty处理粘包、半包的源码</strong></h2><h3 id="解码核心工作流程"><a href="#解码核心工作流程" class="headerlink" title="解码核心工作流程"></a><strong>解码核心工作流程</strong></h3><p>解码入口方法：io.netty.handler.codec.ByteToMessageDecoder#channelRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//参数msg就是传入的数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ByteBuf) &#123;<br>        <span class="hljs-type">CodecOutputList</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> CodecOutputList.newInstance();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//要解析的数据首先转化为data</span><br>            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>            first = cumulation == <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//如果是第一笔数据，就赋值给cumulation数据积累器，也就是在解码前或者解码后都是一个数据积累的过程</span><br>            <span class="hljs-keyword">if</span> (first) &#123;<br>                cumulation = data;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果不是第一笔数据，就追加到cumulation，采用的是策略模式</span><br>                cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);<br>            &#125;<br>            callDecode(ctx, cumulation, out);<br>        &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (cumulation != <span class="hljs-literal">null</span> &amp;&amp; !cumulation.isReadable()) &#123;<br>                numReads = <span class="hljs-number">0</span>;<br>                cumulation.release();<br>                cumulation = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++ numReads &gt;= discardAfterReads) &#123;<br>                <span class="hljs-comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/4275</span><br>                numReads = <span class="hljs-number">0</span>;<br>                discardSomeReadBytes();<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> out.size();<br>            decodeWasNull = !out.insertSinceRecycled();<br>            fireChannelRead(ctx, out, size);<br>            out.recycle();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ctx.fireChannelRead(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数msg就是传入的数据,要解析的数据首先转化为data. 如果是第一笔数据，就赋值给cumulation数据积累器，也就是在解码前或者解码后都是一个数据积累的过程;如果不是第一笔数据，就追加到cumulation，采用的是策略模式。 接着调用callDecode解码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callDecode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//参数in就是数据积累器的数据</span><br>        <span class="hljs-keyword">while</span> (in.isReadable()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">outSize</span> <span class="hljs-operator">=</span> out.size();<br><br>            <span class="hljs-keyword">if</span> (outSize &gt; <span class="hljs-number">0</span>) &#123;<br>                fireChannelRead(ctx, out, outSize);<br>                out.clear();<br><br>                <span class="hljs-comment">// Check if this handler was removed before continuing with decoding.</span><br>                <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See:</span><br>                <span class="hljs-comment">// - https://github.com/netty/netty/issues/4635</span><br>                <span class="hljs-keyword">if</span> (ctx.isRemoved()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                outSize = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">oldInputLength</span> <span class="hljs-operator">=</span> in.readableBytes();<br>            decodeRemovalReentryProtection(ctx, in, out);<br><br>            <span class="hljs-comment">// Check if this handler was removed before continuing the loop.</span><br>            <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/1664</span><br>            <span class="hljs-keyword">if</span> (ctx.isRemoved()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (outSize == out.size()) &#123;<br>                <span class="hljs-keyword">if</span> (oldInputLength == in.readableBytes()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (oldInputLength == in.readableBytes()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(<br>                        StringUtil.simpleClassName(getClass()) +<br>                                <span class="hljs-string">&quot;.decode() did not read anything but decoded a message.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (isSingleDecode()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception cause) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数in就是数据积累器的数据，也就是我们收到的数据，第一次outSize大小肯定为0，所以跳过if语句，然后会调用decodeRemovalReentryProtection（）方法。该方法作用是：在decode中时，是不能执行handler remove清理操作的，在decode完之后需要清理数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decodeRemovalReentryProtection</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    decodeState = STATE_CALLING_CHILD_DECODE;<br>    <span class="hljs-keyword">try</span> &#123;<br>        decode(ctx, in, out);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removePending</span> <span class="hljs-operator">=</span> decodeState == STATE_HANDLER_REMOVED_PENDING;<br>        decodeState = STATE_INIT;<br>        <span class="hljs-keyword">if</span> (removePending) &#123;<br>            handlerRemoved(ctx);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内部会调用decode方法，该方法采用的是模版方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception;<br></code></pre></td></tr></table></figure><p>可以查询子类FixedLengthFrameDecoder，此时就完成一次数据解析的流程。 通过下面的代码就可以发现，处理了粘包和半包的问题。 在编码数据前，先对数据进行积累Cumulator。解码的时候先判断是否小于固定的长度，小的话就是包不全也就不去解码数据，等于的话就直接解(没问题)，大于的话就解对应长度的，多的那部分还是在积累器里面，等下次用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">decode</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@SuppressWarnings(&quot;UnusedParameters&quot;)</span> ChannelHandlerContext ctx, ByteBuf in)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (in.readableBytes() &lt; frameLength) &#123;<span class="hljs-comment">//处理半包的问题</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//处理粘包的问题，多余的数据还会存储在accumation中</span><br>        <span class="hljs-keyword">return</span> in.readRetainedSlice(frameLength);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解码中两种数据积累器的区别"><a href="#解码中两种数据积累器的区别" class="headerlink" title="解码中两种数据积累器的区别"></a><strong>解码中两种数据积累器的区别</strong></h3><h3 id="MERGE-CUMULATOR"><a href="#MERGE-CUMULATOR" class="headerlink" title="MERGE_CUMULATOR"></a><strong>MERGE_CUMULATOR</strong></h3><p>using memory copies</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Cumulator</span> <span class="hljs-variable">MERGE_CUMULATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cumulator</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">cumulate</span><span class="hljs-params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> &#123;<br>        <span class="hljs-keyword">final</span> ByteBuf buffer;<br>        <span class="hljs-comment">//如果容量不够就扩容</span><br>        <span class="hljs-keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()<br>                || cumulation.refCnt() &gt; <span class="hljs-number">1</span> || cumulation.isReadOnly()) &#123;<br>            <span class="hljs-comment">// Expand cumulation (by replace it) when either there is not more room in the buffer</span><br>            <span class="hljs-comment">// or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</span><br>            <span class="hljs-comment">// duplicate().retain() or if its read-only.</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See:</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/2327</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/1764</span><br>            buffer = expandCumulation(alloc, cumulation, in.readableBytes());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            buffer = cumulation;<br>        &#125;<br>        <span class="hljs-comment">//如果容量足够的话，就直接把数据追加进去</span><br>        buffer.writeBytes(in);<br>        in.release();<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="COMPOSITE-CUMULATOR"><a href="#COMPOSITE-CUMULATOR" class="headerlink" title="COMPOSITE_CUMULATOR"></a><strong>COMPOSITE_CUMULATOR</strong></h3><ul><li>ByteBuf通过将它们添加到 CompositeByteBuf 来累积，因此尽可能不复制内存。请注意，使用更复杂的索引实现，CompositeByteBuf因此根据您的用例和解码器实现，这可能会更慢，然后只使用 MERGE_CUMULATOR。</li><li>不是真正的复制，而是提供一个逻辑的视图，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Cumulator</span> <span class="hljs-variable">COMPOSITE_CUMULATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cumulator</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">cumulate</span><span class="hljs-params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> &#123;<br>        ByteBuf buffer;<br>        <span class="hljs-keyword">if</span> (cumulation.refCnt() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the user</span><br>            <span class="hljs-comment">// use slice().retain() or duplicate().retain().</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See:</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/2327</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/1764</span><br>            buffer = expandCumulation(alloc, cumulation, in.readableBytes());<br>            buffer.writeBytes(in);<br>            in.release();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            CompositeByteBuf composite;<br>            <span class="hljs-comment">//创建compositeByteBuf</span><br>            <span class="hljs-keyword">if</span> (cumulation <span class="hljs-keyword">instanceof</span> CompositeByteBuf) &#123;<br>                composite = (CompositeByteBuf) cumulation;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                composite = alloc.compositeBuffer(Integer.MAX_VALUE);<br>                composite.addComponent(<span class="hljs-literal">true</span>, cumulation);<br>            &#125;<br>            <span class="hljs-comment">//避免内存复制</span><br>            composite.addComponent(<span class="hljs-literal">true</span>, in);<br>            buffer = composite;<br>        &#125;<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>MERGE_CUMULATOR是通过copy实现，实际操作的是ByteBuf；COMPOSITE_CUMULATOR操作的CompositeByteBuf可以看做是对ByteBuf的封装，其维护了一个ByteBuf的List列表，每次cumulate操作其实把当前的ByteBuf放到List中。</p><p>我认为这两种cumulate的性能侧重点不同，merge方式提前copy，那么读取时会更快，反之，使用composite的方式在读取时需要遍历List，读取数据时更慢。</p><p>我觉得使用哪种数据累计器主要看decode实现，如果decode的实现包含很多随机读（比如读取第4-8个字节这种），这种情况肯定是基于复制的Cumulator更好，因为复制方式是连续内存，随机读时间复杂度为O(1), 而组合方式是基于数组实现，由于不确定目标内容在数组的位置，所以 需要遍历数组，效率偏低。</p><h3 id="数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？"><a href="#数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？" class="headerlink" title="数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？"></a><strong>数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？</strong></h3><p>因为组合的方式没有经过充分的证明：证明在所有场景下肯定比内存复制的性能要好（毕竟组合方式的指针维护复杂些，如果解码是把组合的直接能拆出来就可以用，那明显会好，例如ssl hanlder里面就有显示设置为组合方式的例子，但是大多不是如此用，仅有的测试也只是表明好一点点而已)，所以自然默认就还是用原始的那种方式，而不是直接切换到后来加的组合方式，另外提供了setCumulator方法让我们有切换的选择。 总结下：不是说1+1不等于2，而是说大家都这么觉得，但是没有人去有力的证明，所以保持怀疑的态度，就保守起见了，没有改默认的。</p><h3 id="三种解码器的常用额外控制参数有哪些"><a href="#三种解码器的常用额外控制参数有哪些" class="headerlink" title="三种解码器的常用额外控制参数有哪些"></a><strong>三种解码器的常用额外控制参数有哪些</strong></h3><table><thead><tr><th>解码器</th><th>变量</th><th></th></tr></thead><tbody><tr><td>FixedLengthFrameDecoder（固定长度解码器）</td><td>frameLength：指定固定的消息长度。 maxFrameLength：可选参数，用于限制解码的帧的最大长度。 lengthFieldOffset、lengthFieldLength、lengthAdjustment、initialBytesToStrip：这些参数用于处理消息中的长度字段，通常用于半包处理。</td><td>支持多种分隔符</td></tr><tr><td>DelimiterBasedFrameDecoder（分隔符解码器）</td><td>maxFrameLength：指定解码的帧的最大长度。 stripDelimiter：指定是否从解码的帧中删除分隔符。 failFast：可选参数，用于控制是否快速失败（即在遇到无效分隔符时立即抛出异常）。</td><td>指定长度</td></tr><tr><td>LengthFieldBasedFrameDecoder（长度字段解码器）</td><td>maxFrameLength：帧的最大长度，超过此长度将抛出 TooLongFrameException异常。 lengthFieldOffset：长度字段的偏移量。 lengthFieldLength：长度字段的长度。 lengthAdjustment：长度字段的补偿值，用于调整帧的长度。 initialBytesToStrip：从解码帧中跳过的前几个字节的数量。 failFast：如果为 true，当解码器注意到帧的长度将超过 maxFrameLength 时立即抛出 TooLongFrameException 异常；如果为 false，在完全读取超过 maxFrameLength 的帧后再抛出异常。</td><td>根据消息中长度字段的值动态拆分接收到的ByteBuf</td></tr></tbody></table><h2 id="5-常用的“二次”编解码方式"><a href="#5-常用的“二次”编解码方式" class="headerlink" title="5.常用的“二次”编解码方式"></a><strong>5.常用的“二次”编解码方式</strong></h2><h3 id="为什么需要二次解码"><a href="#为什么需要二次解码" class="headerlink" title="为什么需要二次解码"></a><strong>为什么需要二次解码</strong></h3><ul><li><p>一次解码器：ByteToMessageDecoder</p></li><li><ul><li>io.netty.buffer.ByteBuf （原始数据流）-&gt; io.netty.buffer.ByteBuf （用户数据）</li></ul></li><li><p>二次解码器：MessageToMessageDecoder</p></li><li><ul><li>io.netty.buffer.ByteBuf （用户数据）-&gt; Java Object</li></ul></li></ul><p>为了分层和降低耦合性，不建议将两次解码合并成一次。</p><h3 id="常用的二次编解码方式"><a href="#常用的二次编解码方式" class="headerlink" title="常用的二次编解码方式"></a><strong>常用的二次编解码方式</strong></h3><p>Java序列号、XML、JSON、Protobuf、MessagePack</p><h3 id="选择编解码方式的要点"><a href="#选择编解码方式的要点" class="headerlink" title="选择编解码方式的要点"></a><strong>选择编解码方式的要点</strong></h3><ol><li>编码后的占用空间大小</li><li>编解码速度</li><li>可读性</li><li>多语言支持</li></ol><h3 id="Protobuf简介与使用"><a href="#Protobuf简介与使用" class="headerlink" title="Protobuf简介与使用"></a><strong>Protobuf简介与使用</strong></h3><ul><li>Protobuf 是一个灵活的、高效的用于序列化数据的协议</li><li>相比较 XML 和 JSON 格式，Protobuf 更小、更快、更便捷。</li><li>Protobuf 是跨语言的，并且自带了一个编译器（protoc），只需要用它进行编译，可 以自动生成 Java、python、C++ 等代码，不需要再写其他代码</li></ul><h2 id="Netty对二次编解码的支持"><a href="#Netty对二次编解码的支持" class="headerlink" title="Netty对二次编解码的支持"></a><strong>Netty对二次编解码的支持</strong></h2><p>以WorldClockClientInitializer中的initChannel方法为例，说明netty是如何进行二次编解码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.example.worldclock.WorldClockClientInitializer<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>    <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ch.pipeline();<br>    <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//添加一个 SSL 处理器到管道中，用于处理安全连接</span><br>        p.addLast(sslCtx.newHandler(ch.alloc(), WorldClockClient.HOST, WorldClockClient.PORT));<br>    &#125;<br><br>    <span class="hljs-comment">//一次解码 得到一个bytebuf</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufVarint32FrameDecoder</span>());<br>    <span class="hljs-comment">//二次解码 得到一个object</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufDecoder</span>(WorldClockProtocol.LocalTimes.getDefaultInstance()));<br><br>    <span class="hljs-comment">//一次编码 解决粘包和半包问题</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufVarint32LengthFieldPrepender</span>());<br>    <span class="hljs-comment">//二次编码 字节数组</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufEncoder</span>());<br><br>    <span class="hljs-comment">//业务流程</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WorldClockClientHandler</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一次解码"><a href="#一次解码" class="headerlink" title="一次解码"></a><strong>一次解码</strong></h3><ul><li>第一次解码：<strong>ProtobufVarint32FrameDecoder</strong> 目的是将具体内容拆分出来，得到一个bytebuf</li></ul><p>Varint &#x3D; 长度字段的长度可变： 值越小的数字使用越少的字节数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">BEFORE <span class="hljs-title function_">DECODE</span> <span class="hljs-params">(<span class="hljs-number">302</span> bytes)</span>       AFTER <span class="hljs-title function_">DECODE</span> <span class="hljs-params">(<span class="hljs-number">300</span> bytes)</span><br>+--------+---------------+      +---------------+<br>| Length | Protobuf Data |-----&gt;| Protobuf Data |<br>| <span class="hljs-number">0xAC02</span> |  (<span class="hljs-number">300</span> bytes)  |      |  (<span class="hljs-number">300</span> bytes)  |<br>+--------+---------------+      +---------------+<br></code></pre></td></tr></table></figure><h3 id="二次解码"><a href="#二次解码" class="headerlink" title="二次解码"></a><strong>二次解码</strong></h3><ul><li>第二次解码：<strong>ProtobufDecoder</strong> 目的是对protobuf中的信息进行具体的处理，得到一个java object<br>在decode方法中，会对传入的bytebuf进行不同情况的处理，先判断是否有extension再判断是否存在HAS_PARSER。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] array;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> offset;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> msg.readableBytes();<br>    <span class="hljs-keyword">if</span> (msg.hasArray()) &#123;<br>        array = msg.array();<br>        offset = msg.arrayOffset() + msg.readerIndex();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        array = ByteBufUtil.getBytes(msg, msg.readerIndex(), length, <span class="hljs-literal">false</span>);<br>        offset = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//带extension 扩展</span><br>    <span class="hljs-keyword">if</span> (extensionRegistry == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//HAS_PARSER when &gt;protobuf 2.5.0</span><br>        <span class="hljs-keyword">if</span> (HAS_PARSER) &#123;<br>            out.add(prototype.getParserForType().parseFrom(array, offset, length));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            out.add(prototype.newBuilderForType().mergeFrom(array, offset, length).build());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (HAS_PARSER) &#123;<br>            out.add(prototype.getParserForType().parseFrom(<br>                    array, offset, length, extensionRegistry));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            out.add(prototype.newBuilderForType().mergeFrom(<br>                    array, offset, length, extensionRegistry).build());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一次编码"><a href="#一次编码" class="headerlink" title="一次编码"></a><strong>一次编码</strong></h3><ul><li>第一次编码：<strong>ProtobufVarint32LengthFieldPrepender</strong>，解决粘包和半包问题。在编码的头部加入length字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">BEFORE <span class="hljs-title function_">ENCODE</span> <span class="hljs-params">(<span class="hljs-number">300</span> bytes)</span>       AFTER <span class="hljs-title function_">ENCODE</span> <span class="hljs-params">(<span class="hljs-number">302</span> bytes)</span><br>+---------------+               +--------+---------------+<br>| Protobuf Data |--------------&gt;| Length | Protobuf Data |<br>|  (<span class="hljs-number">300</span> bytes)  |               | <span class="hljs-number">0xAC02</span> |  (<span class="hljs-number">300</span> bytes)  |<br>+---------------+               +--------+---------------+<br></code></pre></td></tr></table></figure><p>为了实现高性能，还会对不同长度的length进行位运算，以达到使用最少的字节数表达长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">computeRawVarint32Size</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-comment">//根据不同的值返回不同的字节数</span><br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt;  <span class="hljs-number">7</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">14</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">21</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">28</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二次编码"><a href="#二次编码" class="headerlink" title="二次编码"></a><strong>二次编码</strong></h3><ul><li>第二次编码：<strong>ProtobufEncoder</strong> 得到一个字节数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageLiteOrBuilder msg, List&lt;Object&gt; out)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> MessageLite) &#123;<br>        out.add(wrappedBuffer(((MessageLite) msg).toByteArray()));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> MessageLite.Builder) &#123;<br>        out.add(wrappedBuffer(((MessageLite.Builder) msg).build().toByteArray()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Keepalive与idle监测"><a href="#6-Keepalive与idle监测" class="headerlink" title="6.Keepalive与idle监测"></a><strong>6.Keepalive与idle监测</strong></h2><h3 id="为什么要keepalive"><a href="#为什么要keepalive" class="headerlink" title="为什么要keepalive"></a><strong>为什么要keepalive</strong></h3><p>在双方进行通话时，如何对方不讲话了，我们需要问一句“你还在吗？”如果对方没有回复，挂机。这套机制就是keepalive。</p><p><img src="https://pic4.zhimg.com/80/v2-478dfdbf49fb7236f1eed3c3e8c4034f_720w.webp" alt="img"></p><h3 id="怎么设计keepalive？以TCP-keepalive为例"><a href="#怎么设计keepalive？以TCP-keepalive为例" class="headerlink" title="怎么设计keepalive？以TCP keepalive为例"></a><strong>怎么设计keepalive？以TCP keepalive为例</strong></h3><p>TCP keepalive核心参数：</p><blockquote><p>net.ipv4.tcp_keepalive_time &#x3D; 7200 &#x2F;&#x2F;出现问题概率小，没有必要频繁<br>net.ipv4.tcp_keepalive_intvl &#x3D; 75<br>net.ipv4.tcp_keepalive_probes &#x3D; 9 &#x2F;&#x2F;谨慎判断</p></blockquote><p>当启用（默认关闭）keepalive时，TCP在没有数据通过的7200秒后发送keepalive消息，当探测没有确认时，按75秒的重试评论重发，一直法9个探测包都没有确认，就认为连接失败，则关闭连接。</p><p>总耗时 7200+75*9 &#x3D; 2h 11min</p><h3 id="为什么还需要应用层keepalive"><a href="#为什么还需要应用层keepalive" class="headerlink" title="为什么还需要应用层keepalive"></a><strong>为什么还需要应用层keepalive</strong></h3><ul><li>TCP层的keepalive默认关闭 ，而且经过路由等中转设备可能会被丢弃。</li><li>keepalive时间太长（默认&gt;2h），虽然可以改，但是必须要改动所有应用</li><li>各层协议关注点不同。传输层关注是否连接通常，应用层关注是否可服务。电话通了并不代表有人接。</li></ul><p>应用层的keepalive长连接在HTTP1里面有header。HTTP&#x2F;1.1默认是长连接，所以没有这个header</p><h3 id="Idle监测是什么"><a href="#Idle监测是什么" class="headerlink" title="Idle监测是什么"></a><strong>Idle监测是什么</strong></h3><p>在通话场景中，如果对方突然不说话了。那么我们会稍微等待一段时间，看看这个时间内对方还会不会说话（idle），如何还不说，就认为对方存在问题（idle），于是开始发问“你还在吗”（keepalive），或者直接挂机（关闭连接）。</p><ul><li><p>Idle监测只是负责诊断，做出不同的行为后，觉得Idle的最终用途。</p></li><li><p>发送keepalive：<br><strong>keepalive演进</strong></p></li><li><ul><li>v1：定时发送消息（消耗太大）</li><li>v2：有其他数据传输（业务），不发送keepalive。没有数据传输，判定为Idle,再发送keepalive。</li></ul></li><li><p>直接关闭连接</p></li><li><ul><li>快速释放损坏，恶意、不使用的连接</li><li>客户端重连。</li></ul></li></ul><h3 id="如何在Netty中开启TCP-keepalive和Idle监测"><a href="#如何在Netty中开启TCP-keepalive和Idle监测" class="headerlink" title="如何在Netty中开启TCP keepalive和Idle监测"></a><strong>如何在Netty中开启TCP keepalive和Idle监测</strong></h3><h3 id="开启两种风格的keepalive"><a href="#开启两种风格的keepalive" class="headerlink" title="开启两种风格的keepalive"></a><strong>开启两种风格的keepalive</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">.childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>.childOption(NioChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>提示：.option(ChannelOption.SO_KEEPALIVE,true) 存在但是无效</p><h3 id="开启不同的Idle-Check："><a href="#开启不同的Idle-Check：" class="headerlink" title="开启不同的Idle Check："></a><strong>开启不同的Idle Check：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(“idleCheckHandler<span class="hljs-string">&quot;, new IdleStateHandler(0, 20, 0, TimeUnit.SECONDS));</span><br><span class="hljs-string">//----------------------//</span><br><span class="hljs-string">public IdleStateHandler(</span><br><span class="hljs-string">        long readerIdleTime, long writerIdleTime, long allIdleTime,</span><br><span class="hljs-string">        TimeUnit unit) &#123;</span><br><span class="hljs-string">    this(false, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="源码解读Netty对TCP-keepalive和三种Idle监测的支持"><a href="#源码解读Netty对TCP-keepalive和三种Idle监测的支持" class="headerlink" title="源码解读Netty对TCP keepalive和三种Idle监测的支持"></a><strong>源码解读Netty对TCP keepalive和三种Idle监测的支持</strong></h2><h3 id="设置TCP-keepalive怎么生效"><a href="#设置TCP-keepalive怎么生效" class="headerlink" title="设置TCP keepalive怎么生效"></a><strong>设置TCP keepalive怎么生效</strong></h3><p>以EchoServer为例，从设置keepalive的childOption方法进入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. io.netty.bootstrap.ServerBootstrap<span class="hljs-comment">#childOption  </span><br>2.   -&gt; io.netty.bootstrap.ServerBootstrap<span class="hljs-comment">#init  </span><br>3.      -&gt; io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor<span class="hljs-comment">#ServerBootstrapAcceptor  </span><br>4.         -&gt; io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor<span class="hljs-comment">#channelRead</span><br>5.            -&gt; io.netty.bootstrap.AbstractBootstrap<span class="hljs-comment">#setChannelOptions  </span><br>6.              -&gt;io.netty.bootstrap.AbstractBootstrap<span class="hljs-comment">#setChannelOption  </span><br>7.                -&gt; io.netty.channel.socket.nio.NioSocketChannel.NioSocketChannelConfig<span class="hljs-comment">#setOption</span><br></code></pre></td></tr></table></figure><p>1.传入一个普通的channel而不是传入一个serverSocketChannel，在childOption()方法中，对成员变量childOptions进行了设置，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;ChannelOption&lt;?&gt;, Object&gt;();<br></code></pre></td></tr></table></figure><p>2.成员变量childOptions在init()方法中被转化为currentChildOptions。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>ChannelInitializer一次性、初始化handler: 负责添加一个ServerBootstrapAcceptor handler，添加完后，自己就移除了: ServerBootstrapAcceptor handler： 负责接收客户端连接创建连接后，对连接的初始化工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.bootstrap.ServerBootstrap#init <br>    <br>p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>        <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>        <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>            pipeline.addLast(handler);<br>        &#125;<br><br>        ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>3.io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#ServerBootstrapAcceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerBootstrapAcceptor(<span class="hljs-comment">//接受连接后的后续处理</span><br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>4.对于上面的ServerBootstrapAcceptor的后续处理由channelRead()方法进行处理。<strong>将childOption设置到Channel里面去</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (Channel) msg;  <span class="hljs-comment">//msg是一个channel</span><br>    child.pipeline().addLast(childHandler);<br>    setChannelOptions(child, childOptions, logger); <span class="hljs-comment">//设置childOption</span><br>    setAttributes(child, childAttrs);<br>        ......<br>&#125;<br></code></pre></td></tr></table></figure><p>5.io.netty.bootstrap.AbstractBootstrap#setChannelOptions<br>static void setChannelOptions<br>setChannelOption(channel, e.getKey(), e.getValue(), logger);</p><p>6 -&gt; 7.</p><p>7.直到第七步可以看见接口有许多实现类，选择NioSocketChannel，可以看见由nio方式实现的设置keepalive方法。同时，在DefaultChannelConfig中实现了另一种设置keepalive的方式。</p><h3 id="两种设置keepalive的方式有什么区别？"><a href="#两种设置keepalive的方式有什么区别？" class="headerlink" title="两种设置keepalive的方式有什么区别？"></a><strong>两种设置keepalive的方式有什么区别？</strong></h3><ul><li><strong>io.netty.channel.socket.nio.NioSocketChannel</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置指定的选项到指定的 JDK 原生 Channel。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> jdkChannel JDK 原生 Channel</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> option     NioChannelOption 选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value      选项值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;        选项类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果设置成功，则返回 true；否则返回 false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">setOption</span><span class="hljs-params">(Channel jdkChannel, NioChannelOption&lt;T&gt; option, T value)</span> &#123;<br>    <span class="hljs-comment">// 将 JDK 原生 Channel 转换为 NetworkChannel 类型</span><br>    java.nio.channels.<span class="hljs-type">NetworkChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (java.nio.channels.NetworkChannel) jdkChannel;<br><br>    <span class="hljs-comment">// 检查通道是否支持指定的选项</span><br>    <span class="hljs-keyword">if</span> (!channel.supportedOptions().contains(option.option)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果是 ServerSocketChannel 并且选项是 IP_TOS，则跳过设置，作为 JDK bug 的解决方法</span><br>    <span class="hljs-keyword">if</span> (channel <span class="hljs-keyword">instanceof</span> ServerSocketChannel &amp;&amp; option.option == java.net.StandardSocketOptions.IP_TOS) &#123;<br>        <span class="hljs-comment">// 跳过 IP_TOS 选项</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 设置选项到 JDK 原生 Channel</span><br>        channel.setOption(option.option, value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-comment">// 发生异常时，抛出 ChannelException</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>io.netty.channel.socket.nio.DefaultChannelConfig</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置通道选项到 Netty Channel。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> option 选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value  选项值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;    选项类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果设置成功，则返回 true；否则返回 false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">setOption</span><span class="hljs-params">(ChannelOption&lt;T&gt; option, T value)</span> &#123;<br>    <span class="hljs-comment">// 验证选项和值是否有效</span><br>    validate(option, value);<br><br>    <span class="hljs-comment">// 根据选项类型执行相应的设置操作</span><br>    <span class="hljs-keyword">if</span> (option == SO_RCVBUF) &#123;<br>        <span class="hljs-comment">// 设置接收缓冲区大小</span><br>        setReceiveBufferSize((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_SNDBUF) &#123;<br>        <span class="hljs-comment">// 设置发送缓冲区大小</span><br>        setSendBufferSize((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == TCP_NODELAY) &#123;<br>        <span class="hljs-comment">// 设置 TCP_NODELAY</span><br>        setTcpNoDelay((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_KEEPALIVE) &#123;<br>        <span class="hljs-comment">// 设置 SO_KEEPALIVE</span><br>        setKeepAlive((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_REUSEADDR) &#123;<br>        <span class="hljs-comment">// 设置 SO_REUSEADDR</span><br>        setReuseAddress((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_LINGER) &#123;<br>        <span class="hljs-comment">// 设置 SO_LINGER</span><br>        setSoLinger((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == IP_TOS) &#123;<br>        <span class="hljs-comment">// 设置 IP_TOS</span><br>        setTrafficClass((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == ALLOW_HALF_CLOSURE) &#123;<br>        <span class="hljs-comment">// 设置 ALLOW_HALF_CLOSURE</span><br>        setAllowHalfClosure((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 调用父类的 setOption() 方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setOption(option, value);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法分别是<code>Netty</code>框架中的两个不同类中的方法，用于设置通道选项。</p><p><code>setOption(Channel jdkChannel, NioChannelOption&lt;T&gt; option, T value)</code>方法是一个静态方法，用于设置指定的选项到指定的<code>JDK</code>原生<code>Channel</code>。</p><p><code>setOption(ChannelOption&lt;T&gt; option, T value)</code>方法是<code>Channel</code>类的实例方法，用于设置通道选项到<code>Netty</code>的<code>Channel</code>中。</p><p>这两个方法的区别在于，<code>setOption(Channel jdkChannel, NioChannelOption&lt;T&gt; option, T value)</code>方法是用于设置<code>JDK</code>原生<code>Channel</code>的选项，而<code>setOption(ChannelOption&lt;T&gt; option, T value)</code>方法是用于设置<code>Netty</code>的<code>Channel</code>的选项。</p><p>从代码可扩展性来看nio中的方法显然更容易添加和修改，而默认方式很多if&#x2F;else的情况下，如果要修改一个，就会牵一发而动全身。</p><h3 id="Idle检测类包（io-netty-handler-timeout）的功能有哪些"><a href="#Idle检测类包（io-netty-handler-timeout）的功能有哪些" class="headerlink" title="Idle检测类包（io.netty.handler.timeout）的功能有哪些"></a><strong>Idle检测类包（io.netty.handler.timeout）的功能有哪些</strong></h3><p>位置在handler模块下的timeout包</p><p><img src="https://pic3.zhimg.com/80/v2-bdaf9058a99f6b15f44152b9d08d8002_720w.webp" alt="img"></p><h3 id="三种类型Idle"><a href="#三种类型Idle" class="headerlink" title="三种类型Idle"></a>三种类型Idle</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">public enum IdleState &#123;<br> /**<br> * 当在指定时间段内未执行读取时，将触发状态为IdleState.READER_IDLE的IdleStateEvent 。指定0以禁用<br> */<br> READER_IDLE,<br> /**<br> * 当在指定的时间段内没有执行写入时，将触发状态为IdleState.WRITER_IDLE的IdleStateEvent 。指定0以禁用。<br> */<br> WRITER_IDLE,<br> /**<br> * 状态为IdleState.ALL_IDLE的IdleStateEvent将在指定时间段内未执行读取或写入时触发。指定0以禁用。<br> */<br> ALL_IDLE<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>六个Idle状态，分别为第一次和非第一次</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">public class IdleStateEvent &#123;<br>    public static final IdleStateEvent FIRST_READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, true);<br>    public static final IdleStateEvent READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, false);<br>    public static final IdleStateEvent FIRST_WRITER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.WRITER_IDLE, true);<br>    public static final IdleStateEvent WRITER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.WRITER_IDLE, false);<br>    public static final IdleStateEvent FIRST_ALL_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.ALL_IDLE, true);<br>    public static final IdleStateEvent ALL_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.ALL_IDLE, false);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读Idle检测的原理"><a href="#读Idle检测的原理" class="headerlink" title="读Idle检测的原理"></a>读Idle检测的原理</h3><p>读取空闲的监测是通过 <code>IdleStateHandler</code> 和事件触发机制实现的。</p><blockquote><p>用“读”是否超时进行判断</p></blockquote><p><code>IdleStateHandler</code> 是一个用于检测连接空闲状态的处理器，它会根据指定的时间间隔检查连接的读取空闲状态。它内部使用了 <code>ScheduledExecutorService</code> 来定期检查连接的读取状态。</p><p>ReadTimeoutHandler类当在指定时间内没有发生读事件时，抛出异常ReadTimeoutException。在 <code>run()</code> 方法中，首先计算下一个超时的延迟时间 <code>nextDelay</code>。如果当前不是正在读取状态（<code>reading</code> 为 false），则根据当前时间与上次读取时间的差值来调整 <code>nextDelay</code>，以保证超时的准确性。</p><p>接下来，通过判断 <code>nextDelay</code> 的值来确定读取是否已经超时。如果 <code>nextDelay</code> 小于等于 0，表示读取已经超时，需要执行相应的操作。首先，重新调度一个新的超时任务，并更新 <code>readerIdleTimeout</code> 变量。然后，根据 <code>firstReaderIdleEvent</code> 的值判断是否为第一次读取空闲事件。如果是第一次，则设置 <code>firstReaderIdleEvent</code> 为 false，否则表示已经发生过读取空闲事件。</p><p>接下来，尝试创建一个 <code>IdleStateEvent</code> 实例，表示读取空闲事件，并调用 <code>channelIdle()</code> 方法来通知相关的处理器。如果在这个过程中发生异常，将通过调用 <code>ctx.fireExceptionCaught(t)</code> 来传播异常。</p><p>如果 <code>nextDelay</code> 大于 0，表示读取还未超时，需要重新调度一个新的监测任务，使用 <code>nextDelay</code> 作为延迟时间，以便在接下来的时间内继续监测读取空闲状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nextDelay</span> <span class="hljs-operator">=</span> readerIdleTimeNanos;<br>    <span class="hljs-keyword">if</span> (!reading) &#123;<br>        <span class="hljs-comment">//计算是否idle的关键</span><br>        nextDelay -= ticksInNanos() - lastReadTime;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextDelay &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//空闲了</span><br>        <span class="hljs-comment">// Reader is idle - set a new timeout and notify the callback.</span><br>        readerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstReaderIdleEvent;<br>        <span class="hljs-comment">//firstReaderIdleEvent下个读来之前，第一次idle之后，可能触发多次，都属于非第一次idle.</span><br>        firstReaderIdleEvent = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> newIdleStateEvent(IdleState.READER_IDLE, first);<br>            channelIdle(ctx, event);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ctx.fireExceptionCaught(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//重新其一个监测task，用nextdelay时间</span><br>        <span class="hljs-comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span><br>        readerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写Idle检测原理和参数observeOutput用途"><a href="#写Idle检测原理和参数observeOutput用途" class="headerlink" title="写Idle检测原理和参数observeOutput用途"></a><strong>写Idle检测原理和参数observeOutput用途</strong></h3><blockquote><p>用“写”是否完成进行判断</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (timeoutNanos &gt; <span class="hljs-number">0</span>) &#123;<br>        promise = promise.unvoid();<br>        <span class="hljs-comment">//写的时候schedule一个task去检查是否完成了。</span><br>        scheduleTimeout(ctx, promise);<br>    &#125;<br>    ctx.write(msg, promise);<br>&#125;        <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Was not written yet so issue a write timeout</span><br>    <span class="hljs-comment">// The promise itself will be failed with a ClosedChannelException once the close() was issued</span><br>    <span class="hljs-comment">// 判断写是否完成</span><br>    <span class="hljs-keyword">if</span> (!promise.isDone()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeTimedOut(ctx);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ctx.fireExceptionCaught(t);<br>        &#125;<br>    &#125;<br>    removeWriteTimeoutTask(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="observeOutput用途"><a href="#observeOutput用途" class="headerlink" title="observeOutput用途"></a><strong>observeOutput用途</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasOutputChanged</span><span class="hljs-params">(ChannelHandlerContext ctx, <span class="hljs-type">boolean</span> first)</span> &#123;<br>       <span class="hljs-keyword">if</span> (observeOutput) &#123;<br>           <span class="hljs-comment">//正常情况下，false，即写空闲的判断中的写是指写成功，但是实际上，有可能遇到几种情况：</span><br>           <span class="hljs-comment">//（1）写了，但是缓存区满了，写不出去；（2）写了一个大“数据”，写确实在“动”，但是没有完成。</span><br>           <span class="hljs-comment">//所以这个参数，判断是否有“写的意图”，而不是判断“是否写成功”。</span><br>           <span class="hljs-keyword">if</span> (lastChangeCheckTimeStamp != lastWriteTime) &#123;<br>               lastChangeCheckTimeStamp = lastWriteTime;<br><br>               <span class="hljs-comment">// But this applies only if it&#x27;s the non-first call.</span><br>               <span class="hljs-keyword">if</span> (!first) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>           <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> channel.unsafe();<br>           <span class="hljs-type">ChannelOutboundBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> unsafe.outboundBuffer();<br><br>           <span class="hljs-keyword">if</span> (buf != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">messageHashCode</span> <span class="hljs-operator">=</span> System.identityHashCode(buf.current());<br>               <span class="hljs-type">long</span> <span class="hljs-variable">pendingWriteBytes</span> <span class="hljs-operator">=</span> buf.totalPendingWriteBytes();<br>               <span class="hljs-comment">//pendingWriteBytes 不等于上一次的pendingWriteBytes</span><br>               <span class="hljs-keyword">if</span> (messageHashCode != lastMessageHashCode || pendingWriteBytes != lastPendingWriteBytes) &#123;<br>                   lastMessageHashCode = messageHashCode;<br>                   lastPendingWriteBytes = pendingWriteBytes;<br><br>                   <span class="hljs-keyword">if</span> (!first) &#123;<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                   &#125;<br>               &#125;<br><br>               <span class="hljs-type">long</span> <span class="hljs-variable">flushProgress</span> <span class="hljs-operator">=</span> buf.currentProgress();<br>               <span class="hljs-comment">//写进度</span><br>               <span class="hljs-keyword">if</span> (flushProgress != lastFlushProgress) &#123;<br>                   lastFlushProgress = flushProgress;<br><br>                   <span class="hljs-keyword">if</span> (!first) &#123;<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
      <category>极客时间</category>
      
      <category>Netty源码剖析与实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>Java</tag>
      
      <tag>极客时间</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极客时间《netty源码剖析与实战》学习笔记2</title>
    <link href="/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <url>/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h2 id="7-Netty的锁"><a href="#7-Netty的锁" class="headerlink" title="7.Netty的锁"></a><strong>7.Netty的锁</strong></h2><h3 id="分析同步问题的三要素"><a href="#分析同步问题的三要素" class="headerlink" title="分析同步问题的三要素"></a><strong>分析同步问题的三要素</strong></h3><ul><li>原子性，线程切换带来原子性问题</li><li>可见性，缓存带来的可见性问题</li><li>有序性，编译优化产生有序性问题</li></ul><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a><strong>锁的分类</strong></h3><ul><li>对竞争的态度：乐观锁（java.util.concurrent 包中的原子类）、悲观锁（Synchronized）</li><li>对等待锁是否公平：公平锁 new ReentrantLock (true)、非公平锁 new ReentrantLock ()</li><li>是否可以共享：共享锁与独享锁：ReadWriteLock ，其读锁是共享锁，其写锁是独享</li></ul><h2 id="Netty中使用锁的五个关键点"><a href="#Netty中使用锁的五个关键点" class="headerlink" title="Netty中使用锁的五个关键点"></a><strong>Netty中使用锁的五个关键点</strong></h2><h3 id="注意锁的范围和-gt-减少粒度"><a href="#注意锁的范围和-gt-减少粒度" class="headerlink" title="注意锁的范围和-&gt;减少粒度"></a><strong>注意锁的范围和-&gt;减少粒度</strong></h3><p>初始化 channel （io.netty.bootstrap.ServerBootstrap#init） Synchronized method -&gt; Synchronized block 不是将整个方法加锁，而是在代码块上加锁。</p><p>对于option0和attrs0两个不会出现线程安全问题的代码不加锁。</p><p><img src="https://pic1.zhimg.com/80/v2-24033f5c31a99b059aed60d35260ce08_720w.webp" alt="img"></p><h3 id="注意锁对象本身的大小-gt-减少空间占用"><a href="#注意锁对象本身的大小-gt-减少空间占用" class="headerlink" title="注意锁对象本身的大小-&gt;减少空间占用"></a><strong>注意锁对象本身的大小-&gt;减少空间占用</strong></h3><p>统计待发送的字节数（io.netty.channel.ChannelOutboundBuffer AtomicLong -&gt; Volatile long + AtomicLongFieldUpdater</p><p><img src="https://pic1.zhimg.com/80/v2-ece282236aabb36fc72e58da1a537504_720w.webp" alt="img"></p><p>看似代码变复杂了，而且没用。但是从对象所占用的字节数方面来看：</p><p>Atomic long VS long：</p><p>前者是一个对象，包含对象头（object header）以用来保存 hashcode、lock 等信息，32 位系统占 用8字节；64 位系统占 16 字节，所以在 64 位系统情况下：</p><ul><li>volatile long &#x3D; 8 bytes</li><li>AtomicLong &#x3D; 8 bytes （volatile long）+ 16bytes （对象头）+ 8 bytes (引用，不一定是8字节，因为会存在指针压缩等优化) &#x3D; 32 bytes</li></ul><p>至少节约 24 字节!</p><blockquote><p>结论：Atomic* objects -&gt; Volatile primary type + Static Atomic*FieldUpdater</p></blockquote><h3 id="注意锁的速度-gt-提高并发性"><a href="#注意锁的速度-gt-提高并发性" class="headerlink" title="注意锁的速度-&gt;提高并发性"></a><strong>注意锁的速度-&gt;提高并发性</strong></h3><p>netty可以根据不同情况，选择不同的并发包实现。</p><p>当JDK &lt; 1.8时，使用ConcurrentHashMapV8（ConcurrentHashMap 在 JDK8 中的版本）jdk8的实现拷贝到了netty中（现在netty中没有了）。</p><p><img src="https://pic4.zhimg.com/80/v2-032a9d1466742df6f8fe5ce13087058b_720w.webp" alt="img"></p><h3 id="不同场景下选择不同的并发包-gt-因需而变"><a href="#不同场景下选择不同的并发包-gt-因需而变" class="headerlink" title="不同场景下选择不同的并发包-&gt;因需而变"></a><strong>不同场景下选择不同的并发包-&gt;因需而变</strong></h3><ol><li>关闭和等待关闭事件执行器（Event Execute）</li></ol><p>Object.wait&#x2F;notify -&gt; CountDownLatch</p><p>io.netty.util.concurrent.SingleThreadEventExecutor#threadLock：</p><p><img src="https://pic2.zhimg.com/80/v2-c806e34d4d7e9f8667b0fc60a9d6bb19_720w.webp" alt="img"></p><p><strong>Object.wait&#x2F;notify</strong> 需要把要执行的语句放到一个监视器中。</p><ol><li>Nio Event loop中负责存储task的<br>Queue Jdk’s LinkedBlockingQueue <strong>(MPMC多生产者多消费者模式</strong>) -&gt; jctools’ <strong>MPSC(多生产者单消费者模式)</strong> io.netty.util.internal.PlatformDependent.Mpsc#newMpscQueue(int)：</li></ol><p>对于Event loop来说，它只绑定了一个线程，所以只有一个消费者。</p><p>说明优化的基础是建立在具体的场景上的。</p><h3 id="衡量好锁的价值-gt-能不用则不用"><a href="#衡量好锁的价值-gt-能不用则不用" class="headerlink" title="衡量好锁的价值-&gt;能不用则不用"></a><strong>衡量好锁的价值-&gt;能不用则不用</strong></h3><ol><li>局部串行：netty对于每个连接而言，都是一个串行化操作。Channel 的 I&#x2F;O 请求处理 Pipeline 是串行的</li></ol><p><img src="https://pic2.zhimg.com/80/v2-aa171f49bd974476c51f632729e259a9_720w.webp" alt="img"></p><ol><li>整体并行：多个串行化的线程（NioEventLoop）</li></ol><p><img src="https://pic1.zhimg.com/80/v2-53dde61eb68bc34d7e595421281a3d0c_720w.webp" alt="img"></p><p>Netty 应用场景下：局部串行 + 整体并行 &gt; 一个队列 + 多个线程模式:</p><ul><li>降低用户开发难度、逻辑简单、提升处理性能</li><li>避免锁带来的上下文切换和并发保护等额外开销</li></ul><ol><li>避免用锁： 用 ThreadLocal 来避免资源争用，例如 Netty 轻量级的线程池实</li></ol><h2 id="8-Netty如何玩转内存使用"><a href="#8-Netty如何玩转内存使用" class="headerlink" title="8.Netty如何玩转内存使用"></a><strong>8.Netty如何玩转内存使用</strong></h2><p>内存使用的目标：</p><ul><li>内存占用少</li><li>应用速度快</li></ul><p>对于java而言:减少Full GC的STWW（Stop the world）时间</p><h3 id="减少对像本身大小"><a href="#减少对像本身大小" class="headerlink" title="减少对像本身大小"></a><strong>减少对像本身大小</strong></h3><ul><li>用基本类型就不要用包装类</li><li>应该定义成类变量的不要定义为实例变量</li></ul><h3 id="对分配内存进行预估"><a href="#对分配内存进行预估" class="headerlink" title="对分配内存进行预估"></a><strong>对分配内存进行预估</strong></h3><ul><li>对于已经可以预知固定 size 的 HashMap避免扩容 可以提前计算好初始size或者直接使用</li></ul><p>com.google.common.collect.Maps#newHashMapWithExpectedSize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; HashMap&lt;K, V&gt; <span class="hljs-title function_">newHashMapWithExpectedSize</span><span class="hljs-params">(<span class="hljs-type">int</span> expectedSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(capacity(expectedSize));<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">(<span class="hljs-type">int</span> expectedSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (expectedSize &lt; <span class="hljs-number">3</span>) &#123;<br>        CollectPreconditions.checkNonnegative(expectedSize, <span class="hljs-string">&quot;expectedSize&quot;</span>);<br>        <span class="hljs-keyword">return</span> expectedSize + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> expectedSize &lt; <span class="hljs-number">1073741824</span> ? (<span class="hljs-type">int</span>)((<span class="hljs-type">float</span>)expectedSize / <span class="hljs-number">0.75F</span> + <span class="hljs-number">1.0F</span>) : <span class="hljs-number">2147483647</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Netty 根据接受到的数据动态调整（guess）下个要分配的 Buffer 的大小。可参考 io.netty.channel.AdaptiveRecvByteBufAllocator</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 接受数据buffer的容量会尽可能的足够大以接受数据</span><br><span class="hljs-comment">         * 也尽可能的小以不会浪费它的空间</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> actualReadBytes</span><br><span class="hljs-comment">         */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">record</span><span class="hljs-params">(<span class="hljs-type">int</span> actualReadBytes)</span> &#123;<br>    <span class="hljs-comment">//尝试是否可以减小分配的空间仍然能满足需求：</span><br>    <span class="hljs-comment">//尝试方法：当前实际读取的size是否小于或等于打算缩小的尺寸</span><br>    <span class="hljs-keyword">if</span> (actualReadBytes &lt;= SIZE_TABLE[max(<span class="hljs-number">0</span>, index - INDEX_DECREMENT - <span class="hljs-number">1</span>)]) &#123;<br>        <span class="hljs-comment">//decreaseNow: 连续2次尝试减小都可以</span><br>        <span class="hljs-keyword">if</span> (decreaseNow) &#123;<br>            <span class="hljs-comment">//减小</span><br>            index = max(index - INDEX_DECREMENT, minIndex);<br>            nextReceiveBufferSize = SIZE_TABLE[index];<br>            decreaseNow = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            decreaseNow = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断是否实际读取的数据大于等于预估的，如果是，尝试扩容</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (actualReadBytes &gt;= nextReceiveBufferSize) &#123;<br>        index = min(index + INDEX_INCREMENT, maxIndex);<br>        nextReceiveBufferSize = SIZE_TABLE[index];<br>        decreaseNow = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Zero-Copy-零复制"><a href="#Zero-Copy-零复制" class="headerlink" title="Zero-Copy 零复制"></a><strong>Zero-Copy 零复制</strong></h3><p>使用逻辑组合，代替实际复制。 例如 CompositeByteBuf： io.netty.handler.codec.ByteToMessageDecoder#COMPOSITE_CUMULATOR 避免了内存的复制而将数据组合到一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Cumulator</span> <span class="hljs-variable">COMPOSITE_CUMULATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cumulator</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">cumulate</span><span class="hljs-params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> &#123;<br>        ByteBuf buffer;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (cumulation.refCnt() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the</span><br>                <span class="hljs-comment">// user use slice().retain() or duplicate().retain().</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See:</span><br>                <span class="hljs-comment">// - https://github.com/netty/netty/issues/2327</span><br>                <span class="hljs-comment">// - https://github.com/netty/netty/issues/1764</span><br>                buffer = expandCumulation(alloc, cumulation, in.readableBytes());<br>                buffer.writeBytes(in);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                CompositeByteBuf composite;<br><br>                <span class="hljs-comment">//创建composite bytebuf，如果已经创建过，就不用了</span><br>                <span class="hljs-keyword">if</span> (cumulation <span class="hljs-keyword">instanceof</span> CompositeByteBuf) &#123;<br>                    composite = (CompositeByteBuf) cumulation;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    composite = alloc.compositeBuffer(Integer.MAX_VALUE);<br>                    composite.addComponent(<span class="hljs-literal">true</span>, cumulation);<br>                &#125;<br>                <span class="hljs-comment">//避免内存复制</span><br>                composite.addComponent(<span class="hljs-literal">true</span>, in);<br>                in = <span class="hljs-literal">null</span>;<br>                buffer = composite;<br>            &#125;<br>            <span class="hljs-keyword">return</span> buffer;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (in != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// We must release if the ownership was not transferred as otherwise it may produce a leak if</span><br>                <span class="hljs-comment">// writeBytes(...) throw for whatever release (for example because of OutOfMemoryError).</span><br>                in.release();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>使用包装，代替实际复制。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = data.getBytes();  <br><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(bytes)<br></code></pre></td></tr></table></figure><ul><li>调用 JDK 的 Zero-Copy 接口。 Netty 中也通过在 DefaultFileRegion 中包装了 NIO 的 FileChannel.transferTo() 方法实 现了零拷贝：io.netty.channel.DefaultFileRegion#transferTo</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(WritableByteChannel target, <span class="hljs-type">long</span> position)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count - position;<br>    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span> || position &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                <span class="hljs-string">&quot;position out of range: &quot;</span> + position +<br>                <span class="hljs-string">&quot; (expected: 0 - &quot;</span> + (<span class="hljs-built_in">this</span>.count - <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;)&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (refCnt() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalReferenceCountException</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// Call open to make sure fc is initialized. This is a no-oop if we called it before.</span><br>    open();<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">written</span> <span class="hljs-operator">=</span> file.transferTo(<span class="hljs-built_in">this</span>.position + position, count, target);<br>    <span class="hljs-keyword">if</span> (written &gt; <span class="hljs-number">0</span>) &#123;<br>        transferred += written;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (written == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// If the amount of written data is 0 we need to check if the requested count is bigger then the</span><br>        <span class="hljs-comment">// actual file itself as it may have been truncated on disk.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/8868</span><br>        validate(<span class="hljs-built_in">this</span>, position);<br>    &#125;<br>    <span class="hljs-keyword">return</span> written;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a><strong>堆外内存</strong></h3><p>堆外内存生活场景：</p><ul><li><p>夏日，小区周边的烧烤店铺，人满为患坐不下，店家常常怎么办？</p></li><li><p>解决思路：店铺门口摆很多桌子招待客人。</p></li><li><ul><li>店内 -&gt; JVM 内部 -&gt; 堆（heap) + 非堆（non heap）</li><li>店外 -&gt; JVM 外部 -&gt; 堆外（off heap）</li></ul></li></ul><p>优点：</p><ul><li>更广阔的“空间 ”，缓解店铺内压力 -&gt; 破除堆空间限制，减轻 GC 压力</li><li>减少“冗余”细节（假设烧烤过程为了气氛在室外进行：烤好直接上桌：vs 烤好还 要进店内）-&gt; 避免复制</li></ul><p>缺点：</p><ul><li>需要搬桌子 -&gt; 创建速度稍慢</li><li>受城管管、风险大 -&gt; 堆外内存受操作系统管理</li></ul><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a><strong>内存池</strong></h3><p><strong>点菜单的演进：</strong></p><p>• 一张纸：一桌客人一张纸</p><p>• 点菜平板：循环使用</p><p><strong>为什么引入对象池：</strong></p><p>• 创建对象开销大</p><p>• 对象高频率创建且可复用</p><p>• 支持并发又能保护系统</p><p>• 维护、共享有限的资源</p><p><strong>如何实现对象池？</strong></p><p>• 开源实现：Apache Commons Pool （全局共享，资源争用比较厉害）</p><p>• Netty 轻量级对象池实现 io.netty.util.Recycler （基于netty场景实现）</p><h2 id="源码解读Netty内存使用"><a href="#源码解读Netty内存使用" class="headerlink" title="源码解读Netty内存使用"></a><strong>源码解读Netty内存使用</strong></h2><h3 id="内存池-x2F-非内存池的默认选择及切换方式？"><a href="#内存池-x2F-非内存池的默认选择及切换方式？" class="headerlink" title="内存池&#x2F;非内存池的默认选择及切换方式？"></a><strong>内存池&#x2F;非内存池的默认选择及切换方式？</strong></h3><p>以io.netty.allocator.type为准，没有的话，安卓平台用非池化实现，其他用池化实现</p><p><strong>默认使用池化的实现</strong>，可以使用io.netty.allocator.type设置池化或者非池化的实现。 io.netty.channel.DefaultChannelConfig#allocator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认bytebuf分配器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ByteBufAllocator</span> <span class="hljs-variable">allocator</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT;<br></code></pre></td></tr></table></figure><p>io.netty.buffer.ByteBufAllocator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBufAllocator</span> <span class="hljs-variable">DEFAULT</span> <span class="hljs-operator">=</span> ByteBufUtil.DEFAULT_ALLOCATOR;<br></code></pre></td></tr></table></figure><p>io.netty.buffer.ByteBufUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ByteBufAllocator DEFAULT_ALLOCATOR;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//以io.netty.allocator.type为判断标准，没有的话，安卓平台用非池化实现，其他用池化实现。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">allocType</span> <span class="hljs-operator">=</span> SystemPropertyUtil.get(<br>                <span class="hljs-string">&quot;io.netty.allocator.type&quot;</span>, PlatformDependent.isAndroid() ? <span class="hljs-string">&quot;unpooled&quot;</span> : <span class="hljs-string">&quot;pooled&quot;</span>);<br>        allocType = allocType.toLowerCase(Locale.US).trim();<br>        ByteBufAllocator alloc;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;unpooled&quot;</span>.equals(allocType)) &#123;<br>            alloc = UnpooledByteBufAllocator.DEFAULT;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;</span>, allocType);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;pooled&quot;</span>.equals(allocType)) &#123;<br>            alloc = PooledByteBufAllocator.DEFAULT;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;</span>, allocType);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//io.netty.allocator.type设置的不是&quot;unpooled&quot;或者&quot;pooled&quot;，就用池化实现。</span><br>            alloc = PooledByteBufAllocator.DEFAULT;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.allocator.type: pooled (unknown: &#123;&#125;)&quot;</span>, allocType);<br>        &#125;<br>        DEFAULT_ALLOCATOR = alloc;<br>        THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.threadLocalDirectBufferSize&quot;</span>, <span class="hljs-number">0</span>);<br>        logger.debug(<span class="hljs-string">&quot;-Dio.netty.threadLocalDirectBufferSize: &#123;&#125;&quot;</span>, THREAD_LOCAL_BUFFER_SIZE);<br>        MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.maxThreadLocalCharBufferSize&quot;</span>, <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>);<br>        logger.debug(<span class="hljs-string">&quot;-Dio.netty.maxThreadLocalCharBufferSize: &#123;&#125;&quot;</span>, MAX_CHAR_BUFFER_SIZE);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="两种设置池化实现的方式"><a href="#两种设置池化实现的方式" class="headerlink" title="两种设置池化实现的方式"></a><strong>两种设置池化实现的方式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">.childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)<br> <span class="hljs-type">String</span> <span class="hljs-variable">allocType</span> <span class="hljs-operator">=</span> SystemPropertyUtil.get(<br>                <span class="hljs-string">&quot;io.netty.allocator.type&quot;</span>, PlatformDependent.isAndroid() ? <span class="hljs-string">&quot;unpooled&quot;</span> : <span class="hljs-string">&quot;pooled&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="堆外内存的分配本质？内存池实现"><a href="#堆外内存的分配本质？内存池实现" class="headerlink" title="堆外内存的分配本质？内存池实现?"></a><strong>堆外内存的分配本质？内存池实现?</strong></h3><p>io.netty.buffer.PooledDirectByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <br>    <span class="hljs-comment">//Recycler就是Netty的轻量级内存池的实现</span><br>    Recycler&lt;PooledDirectByteBuf&gt; RECYCLER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Recycler</span>&lt;PooledDirectByteBuf&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> PooledDirectByteBuf <span class="hljs-title function_">newObject</span><span class="hljs-params">(Handle&lt;PooledDirectByteBuf&gt; handle)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledDirectByteBuf</span>(handle, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//从“池”里借一个用</span><br>    <span class="hljs-keyword">static</span> PooledDirectByteBuf <span class="hljs-title function_">newInstance</span><span class="hljs-params">(<span class="hljs-type">int</span> maxCapacity)</span> &#123;<br>        <span class="hljs-type">PooledDirectByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> RECYCLER.get();<br>        buf.reuse(maxCapacity);<br>        <span class="hljs-keyword">return</span> buf;<br>    &#125;<br></code></pre></td></tr></table></figure><p>io.netty.util.Recycler 从池中取对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxCapacityPerThread == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//表明没有开启池化</span><br>        <span class="hljs-keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);<br>    &#125;<br>    Stack&lt;T&gt; stack = threadLocal.get();<br>    DefaultHandle&lt;T&gt; handle = stack.pop();<br>    <span class="hljs-comment">//试图从“池”中取出一个，没有就新建一个</span><br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">null</span>) &#123;<br>        handle = stack.newHandle();<br>        handle.value = newObject(handle);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) handle.value;<br>&#125;<br></code></pre></td></tr></table></figure><p>io.netty.buffer.PooledByteBuf 还对象到池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//归还对象到“池”里去，pipeline的tail会调用</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deallocate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (handle &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.handle;<br>        <span class="hljs-built_in">this</span>.handle = -<span class="hljs-number">1</span>;<br>        memory = <span class="hljs-literal">null</span>;<br>        chunk.arena.free(chunk, tmpNioBuf, handle, maxLength, cache);<br>        tmpNioBuf = <span class="hljs-literal">null</span>;<br>        chunk = <span class="hljs-literal">null</span>;<br>        recycle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>io.netty.util.Recycler的default实现，具体写明如何还回到内存池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultHandle</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handle</span>&lt;T&gt; &#123;<br>    ......<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recycle</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-keyword">if</span> (object != value) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;object does not belong to handle&quot;</span>);<br>        &#125;<br><br>        Stack&lt;?&gt; stack = <span class="hljs-built_in">this</span>.stack;<br>        <span class="hljs-keyword">if</span> (lastRecycledId != recycleId || stack == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;recycled already&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//释放用完的对象到池里面去</span><br>        stack.push(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="怎么从堆外内存切换堆内使用？"><a href="#怎么从堆外内存切换堆内使用？" class="headerlink" title="怎么从堆外内存切换堆内使用？"></a><strong>怎么从堆外内存切换堆内使用？</strong></h3><p>io.netty.util.internal.PlatformDependent</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">// We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.<br>//使用堆外内存两个条件：1 有cleaner方法去释放堆外内存； 2 io.netty.noPreferDirect 不能设置为true<br>DIRECT_BUFFER_PREFERRED = CLEANER != NOOP<br>    &amp;&amp; !SystemPropertyUtil.getBoolean(&quot;io.netty.noPreferDirect&quot;, false);<br>if (logger.isDebugEnabled()) &#123;<br>    logger.debug(&quot;-Dio.netty.noPreferDirect: &#123;&#125;&quot;, !DIRECT_BUFFER_PREFERRED);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法 1：参数设置 io.netty.noPreferDirect &#x3D; true;</li><li>方法 2：传入构造参数false<br>ServerBootstrap serverBootStrap &#x3D; new ServerBootstrap();<br>UnpooledByteBufAllocator unpooledByteBufAllocator &#x3D; new UnpooledByteBufAllocator(false); &#x2F;&#x2F;不推荐<br>serverBootStrap.childOption(ChannelOption.ALLOCATOR, unpooledByteBufAllocator)</li></ul><h3 id="堆外内存的分配本质？"><a href="#堆外内存的分配本质？" class="headerlink" title="堆外内存的分配本质？"></a><strong>堆外内存的分配本质？</strong></h3><p>首先在io.netty.buffer.UnpooledByteBufAllocator会先进行判断，是否有hasUnsafe()方法和是否有noCleaner()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ByteBuf <span class="hljs-title function_">newDirectBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">int</span> maxCapacity)</span> &#123;<br>       <span class="hljs-keyword">final</span> ByteBuf buf;<br>       <span class="hljs-keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;<br>           buf = noCleaner ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</span>(<span class="hljs-built_in">this</span>, initialCapacity, maxCapacity) :<br>                   <span class="hljs-comment">//大多情况：</span><br>                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstrumentedUnpooledUnsafeDirectByteBuf</span>(<span class="hljs-built_in">this</span>, initialCapacity, maxCapacity);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstrumentedUnpooledDirectByteBuf</span>(<span class="hljs-built_in">this</span>, initialCapacity, maxCapacity);<br>       &#125;<br>       <span class="hljs-keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);<br>   &#125;<br></code></pre></td></tr></table></figure><p>io.netty.buffer.UnpooledDirectByteBuf#allocateDirect，最终实际调用的是JDK的方法</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
      <category>极客时间</category>
      
      <category>Netty源码剖析与实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>Java</tag>
      
      <tag>极客时间</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty入门</title>
    <link href="/2023/06/21/netty%E5%85%A5%E9%97%A8/"/>
    <url>/2023/06/21/netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1、简述"><a href="#1、简述" class="headerlink" title="1、简述"></a>1、简述</h2><p>netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端</p><p><a href="https://netty.io/"> netty.io</a></p><h2 id="2、为什么使用netty"><a href="#2、为什么使用netty" class="headerlink" title="2、为什么使用netty"></a>2、为什么使用netty</h2><h3 id="NIO缺点"><a href="#NIO缺点" class="headerlink" title="NIO缺点"></a>NIO缺点</h3><ul><li>api繁杂，</li><li>需要熟悉java多线程，网络编程</li><li>epoll bug会导致selector空轮询，最终导致cpu 100%</li></ul><h3 id="netty优点"><a href="#netty优点" class="headerlink" title="netty优点"></a>netty优点</h3><ul><li>api简单</li><li>支持多种协议</li><li>性能高</li><li>社区活跃</li></ul><h2 id="3、架构"><a href="#3、架构" class="headerlink" title="3、架构"></a>3、架构</h2><p><img src="/img/netty%E5%85%A5%E9%97%A8/image-20230306195432035.png" alt="image-20230306195432035"></p><ol><li><strong>绿色 core</strong>：零拷贝、api库、可扩展事件模型</li><li><strong>黄色 protocol Support协议</strong> 包括http、websocket ssl等等</li><li><strong>红色 传输服务</strong> socket http tunnel等等</li></ol><h2 id="4、hello-word"><a href="#4、hello-word" class="headerlink" title="4、hello word"></a>4、hello word</h2><img src="https://pic4.zhimg.com/80/v2-7eefba893a65706eb6bbe4115cbd0b83_720w.webp" alt="img" style="zoom: 80%;" /><p>根据上面图上的模型进行编写hello word，</p><h3 id="4-1-创建服务端启动类"><a href="#4-1-创建服务端启动类" class="headerlink" title="4.1 创建服务端启动类"></a>4.1 创建服务端启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建两个线程组 boosGroup、workerGroup</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建服务端的启动对象，设置参数</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            <span class="hljs-comment">//设置两个线程组boosGroup和workerGroup</span><br>            bootstrap.group(bossGroup, workerGroup)<br>                <span class="hljs-comment">//设置服务端通道实现类型    </span><br>                .channel(NioServerSocketChannel.class)<br>                <span class="hljs-comment">//设置线程队列得到连接个数    </span><br>                .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                <span class="hljs-comment">//设置保持活动连接状态    </span><br>                .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//使用匿名内部类的形式初始化通道对象    </span><br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">//给pipeline管道设置处理器</span><br>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServerHandler</span>());<br>                        &#125;<br>                    &#125;);<span class="hljs-comment">//给workerGroup的EventLoop对应的管道设置处理器</span><br>            System.out.println(<span class="hljs-string">&quot;java技术爱好者的服务端已经准备就绪...&quot;</span>);<br>            <span class="hljs-comment">//绑定端口号，启动服务端</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(<span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">//对关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-创建服务端处理器"><a href="#4-2-创建服务端处理器" class="headerlink" title="4.2 创建服务端处理器"></a>4.2 创建服务端处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的Handler需要继承Netty规定好的HandlerAdapter</span><br><span class="hljs-comment"> * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取客户端发送过来的消息</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;收到客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;发送的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//发送消息给客户端</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;服务端已收到消息，并给你发送一个问号?&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//发生异常，关闭通道</span><br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3创建客户端启动类"><a href="#4-3创建客户端启动类" class="headerlink" title="4.3创建客户端启动类"></a>4.3创建客户端启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">eventExecutors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建bootstrap对象，配置参数</span><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            <span class="hljs-comment">//设置线程组</span><br>            bootstrap.group(eventExecutors)<br>                <span class="hljs-comment">//设置客户端的通道实现类型    </span><br>                .channel(NioSocketChannel.class)<br>                <span class="hljs-comment">//使用匿名内部类初始化通道</span><br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">//添加客户端通道的处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;客户端准备就绪，随时可以起飞~&quot;</span>);<br>            <span class="hljs-comment">//连接服务端</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">//对通道关闭进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭线程组</span><br>            eventExecutors.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4创建客户端处理器"><a href="#4-4创建客户端处理器" class="headerlink" title="4.4创建客户端处理器"></a>4.4创建客户端处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//发送消息到服务端</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//接收服务端发送过来的消息</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;收到服务端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5测试"><a href="#4-5测试" class="headerlink" title="4.5测试"></a>4.5测试</h3><p>先运行server再运行client</p><p>MyServer打印结果:</p><p><img src="https://pic1.zhimg.com/80/v2-aa144d6ad2688f69b0f5ef7dc916a3f4_720w.webp" alt="img"></p><p>MyClient打印结果：</p><p><img src="https://pic4.zhimg.com/80/v2-e6bc4dec6eecb3ae30f55c7a6487e1f7_720w.webp" alt="img"></p><h2 id="5、netty的特性和重要组件"><a href="#5、netty的特性和重要组件" class="headerlink" title="5、netty的特性和重要组件"></a>5、netty的特性和重要组件</h2><h3 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h3><p>如果handler出来又一些长时间的业务处理，那么可以交给taskQueue异步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取到线程池eventLoop，添加线程，执行</span><br>        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span><br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-schedduleTaskQueue延时任务队列"><a href="#5-2-schedduleTaskQueue延时任务队列" class="headerlink" title="5.2 schedduleTaskQueue延时任务队列"></a>5.2 schedduleTaskQueue延时任务队列</h3><p>和任务队列相似，不同的是可以延迟一定时间再执行设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;,<span class="hljs-number">5</span>, TimeUnit.SECONDS);<span class="hljs-comment">//5秒后执行</span><br></code></pre></td></tr></table></figure><h3 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h3><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666);<br></code></pre></td></tr></table></figure><p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p><p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p><h3 id="5-4-BootStrap-和ServerBootStrap"><a href="#5-4-BootStrap-和ServerBootStrap" class="headerlink" title="5.4 BootStrap 和ServerBootStrap"></a>5.4 BootStrap 和ServerBootStrap</h3><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p><p><img src="https://pic1.zhimg.com/80/v2-dab6b780993979fcb86ef14553c16720_720w.webp" alt="img"></p><p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p><p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p><p><img src="https://pic4.zhimg.com/80/v2-dd3a866c356ee7bd24d23319d08116ef_720w.webp" alt="img"></p><h4 id="1）-group"><a href="#1）-group" class="headerlink" title="1） group()"></a>1） group()</h4><p>服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并且把连接注册到workerGroup的Selector中。</li><li>workerGroup 处理每一个连接发生的读写时间。</li></ul><p><strong>线程组中线程数是多少？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用一个常量保存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DEFAULT_EVENT_LOOP_THREADS;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量</span><br>        DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<br>                <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));<br><br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor, Object... args)</span> &#123;<br>        <span class="hljs-comment">//如果不传入，则使用常量的值，也就是cpu核数的两倍</span><br>        <span class="hljs-built_in">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="2）channel"><a href="#2）channel" class="headerlink" title="2）channel()"></a>2）channel()</h4><p>通道类型有：</p><p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。</p><p><strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p></blockquote><p><strong>OioSocketChannel：</strong> 同步阻塞的客户端 TCP Socket 连接。</p><p><strong>OioServerSocketChannel：</strong> 同步阻塞的服务器端 TCP Socket 连接。</p><p><strong>NioSctpChannel：</strong> 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。</p><p><strong>NioSctpServerChannel</strong>： 异步的 Sctp 服务器端连接。</p><h4 id="3）option-childOption"><a href="#3）option-childOption" class="headerlink" title="3）option() childOption()"></a>3）option() childOption()</h4><ul><li>option设置的是服务端用于接收进来的连接，也就是bossGroup</li><li>childOption是提供给父管道接收的连接，workerGroup</li></ul><p>SocketChannel参数，也就是childOption()常用的参数：</p><blockquote><p><strong>SO_RCVBUF</strong> Socket参数，TCP数据接收缓冲区大小。<br><strong>TCP_NODELAY</strong> TCP参数，立即发送数据，默认值为Ture。<br><strong>SO_KEEPALIVE</strong> Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p></blockquote><p>ServerSocketChannel参数，也就是option()常用参数：</p><blockquote><p><strong>SO_BACKLOG</strong> Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p></blockquote><h4 id="4）设置流水线（重点）"><a href="#4）设置流水线（重点）" class="headerlink" title="4）设置流水线（重点）"></a>4）设置流水线（重点）</h4><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p><p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用匿名内部类的形式初始化通道对象</span><br>bootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//给pipeline管道设置自定义的处理器</span><br>        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServerHandler</span>());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>处理器Handler主要分为两种：</p><blockquote><p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p></blockquote><p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p><p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p><p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p><ol><li>注册事件 fireChannelRegistered。</li><li>连接建立事件 fireChannelActive。</li><li>读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</li><li>异常通知事件 fireExceptionCaught。</li><li>用户自定义事件 fireUserEventTriggered。</li><li>Channel 可写状态变化事件 fireChannelWritabilityChanged。</li><li>连接关闭事件 fireChannelInactive。</li></ol><p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p><ol><li>端口绑定 bind。</li><li>连接服务端 connect。</li><li>写事件 write。</li><li>刷新时间 flush。</li><li>读事件 read。</li><li>主动断开连接 disconnect。</li><li>关闭 channel 事件 close。</li></ol><h4 id="5）-bind"><a href="#5）-bind" class="headerlink" title="5） bind()"></a>5） bind()</h4><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步</p><h3 id="5、-channel"><a href="#5、-channel" class="headerlink" title="5、 channel"></a>5、 channel</h3><p>channel为用户提供：</p><ol><li>通道当前的状态（例如它是打开？还是已连接？）</li><li>channel的配置参数（例如接收缓冲区的大小）</li><li>channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</li></ol><h4 id="1）获取状态"><a href="#1）获取状态" class="headerlink" title="1）获取状态"></a>1）获取状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isOpen</span><span class="hljs-params">()</span>; <span class="hljs-comment">//如果通道打开，则返回true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isRegistered</span><span class="hljs-params">()</span>;<span class="hljs-comment">//如果通道注册到EventLoop，则返回true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isActive</span><span class="hljs-params">()</span>;<span class="hljs-comment">//如果通道处于活动状态并且已连接，则返回true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isWritable</span><span class="hljs-params">()</span>;<span class="hljs-comment">//当且仅当I/O线程将立即执行请求的写入操作时，返回true。</span><br></code></pre></td></tr></table></figure><h4 id="2）获取配置"><a href="#2）获取配置" class="headerlink" title="2）获取配置"></a>2）获取配置</h4><p>获取单条配置信息，使用getOption()，代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> channel.config();<span class="hljs-comment">//获取配置参数</span><br><span class="hljs-comment">//获取ChannelOption.SO_BACKLOG参数,</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">soBackLogConfig</span> <span class="hljs-operator">=</span> config.getOption(ChannelOption.SO_BACKLOG);<br><span class="hljs-comment">//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128</span><br></code></pre></td></tr></table></figure><p>获取多条配置信息，使用getOptions()，代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> channel.config();<br>Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot; : &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）io操作"><a href="#3）io操作" class="headerlink" title="3）io操作"></a>3）io操作</h4><p>写操作 服务端到客户端</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ctx.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;这波啊，这波是肉蛋葱鸡~&quot;, CharsetUtil.UTF_8));<br></code></pre></td></tr></table></figure><p>连接</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ChannelFuture connect = channelFuture.channel().connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));//一般使用启动器，这种方式不常用<br></code></pre></td></tr></table></figure><p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">//获取ChannelPipeline对象<br>ChannelPipeline pipeline = ctx.channel().pipeline();<br>//往pipeline中添加ChannelHandler处理器，装配流水线<br>pipeline.addLast(new MyServerHandler());<br></code></pre></td></tr></table></figure><h3 id="6、Selector"><a href="#6、Selector" class="headerlink" title="6、Selector"></a>6、Selector</h3><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw">《NIO入门》</a>中，我已经讲过Selector了。</p><p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p><h3 id="7、PiPeline与ChannelPipeline"><a href="#7、PiPeline与ChannelPipeline" class="headerlink" title="7、PiPeline与ChannelPipeline"></a>7、PiPeline与ChannelPipeline</h3><p>我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p><p><img src="/img/netty%E5%85%A5%E9%97%A8/image-20230307193519223.png" alt="image-20230307193519223"></p><p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。</p><p><img src="/img/netty%E5%85%A5%E9%97%A8/image-20230307193528870.png" alt="image-20230307193528870"></p><p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p><h3 id="8、ChannelHandlerContext"><a href="#8、ChannelHandlerContext" class="headerlink" title="8、ChannelHandlerContext"></a>8、ChannelHandlerContext</h3><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p><p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。</p><p><img src="/img/netty%E5%85%A5%E9%97%A8/image-20230307193637688.png" alt="image-20230307193637688"></p><p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p><p><img src="/img/netty%E5%85%A5%E9%97%A8/image-20230307193702314.png" alt="image-20230307193702314"></p><h3 id="9、EventLoopGroup"><a href="#9、EventLoopGroup" class="headerlink" title="9、EventLoopGroup"></a>9、EventLoopGroup</h3><p><img src="/img/netty%E5%85%A5%E9%97%A8/image-20230307193734269.png" alt="image-20230307193734269"></p><p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p><p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p><p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p><h4 id="1）轮询机制实现原理"><a href="#1）轮询机制实现原理" class="headerlink" title="1）轮询机制实现原理"></a>1）轮询机制实现原理</h4><p>如果线程数是2的n次方，则采用这种算法。通过算发实现轮询。</p><p>index++ 对数组长度取模</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">private final AtomicInteger idx = new AtomicInteger();<br>private final EventExecutor[] executors;<br><br>@Override<br>public EventExecutor next() &#123;<br>    //idx.getAndIncrement()相当于idx++，然后对任务长度取模<br>    return executors[idx.getAndIncrement() &amp; executors.length - 1];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
