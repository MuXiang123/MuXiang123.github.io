<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/06/21/hello-world/"/>
    <url>/2023/06/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>极客时间《netty源码剖析与实战》学习笔记1</title>
    <link href="/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h2 id="Netty是什么"><a href="#Netty是什么" class="headerlink" title="Netty是什么"></a>Netty是什么</h2><p>netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端</p><p><a href="https://link.zhihu.com/?target=https://netty.io/">官网 netty.io</a></p><p>netty架构</p><p><img src="https://pic3.zhimg.com/80/v2-29b44a34e39f5dfff4bcf13a61d9bad6_720w.webp" alt="img"></p><h2 id="和JDK-NIO的对比"><a href="#和JDK-NIO的对比" class="headerlink" title="和JDK NIO的对比"></a>和JDK NIO的对比</h2><p>Netty做的更多：</p><ul><li>支持常用应用层协议；</li><li>解决传输问题：粘包、半包现象；</li><li>支持流量整形； 完善的断连、Idle异常处理等。</li><li>API更友好更强大： 例如bytebuffer -&gt; netty bytebuf threadlocal -&gt; fastthreadlocal 隔离变化、屏蔽细节 隔离jdk nio实现细节： nio -&gt; nio2(aio)</li><li>规避JDK NIO BUG：</li></ul><p><img src="https://pic2.zhimg.com/80/v2-e979f9b54145122a8b3513aa6f34af35_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-b562cb059d9a83a33e6a9bf355f44b89_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-738b0a68dfc6d012f9e6b68bdf21d1ea_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-d464beb2f6b5ad7e6c32dc584ced204d_720w.webp" alt="img"></p><h3 id="NIO缺点"><a href="#NIO缺点" class="headerlink" title="NIO缺点"></a>NIO缺点</h3><ul><li>api繁杂，</li><li>需要熟悉java多线程，网络编程</li><li>epoll bug会导致selector空轮询，最终导致cpu 100%</li></ul><h3 id="netty优点"><a href="#netty优点" class="headerlink" title="netty优点"></a>netty优点</h3><ul><li>api简单</li><li>支持多种协议</li><li>性能高</li><li>社区活跃</li></ul><h2 id="Netty竞品"><a href="#Netty竞品" class="headerlink" title="Netty竞品"></a>Netty竞品</h2><ul><li>apache mina（同一作者，推荐Netty）</li></ul><p><img src="https://pic1.zhimg.com/80/v2-d0c37ab03af208660b4674387b48fea8_720w.webp" alt="img"></p><ul><li>sun grizzly(用得少、文档少、更新少)</li><li>apple swift nio、ACE（其他语言，不考虑）</li><li>Cindy（生命周期不长）</li><li>tomcat、jetty（还没有独立出来）</li></ul><h2 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h2><ul><li>2004年6月 Netty2发布</li><li>2008年10月Netty3发布</li><li>2013年7月Netty4发布</li><li>2013年12月发布Netty 5.0.0 alpha</li><li>2015年11月废弃5.0.0（废弃原因： 复杂、没有证明明显性能优势、维护不过来，主要维护3.10.X、4.0.X、4.1.X）</li></ul><h2 id="典型使用项目"><a href="#典型使用项目" class="headerlink" title="典型使用项目"></a>典型使用项目</h2><ul><li>数据库： Cassandra</li><li>大数据处理：Spark、Hadoop</li><li>MQ: RocketMQ</li><li>搜索：Elasticsearch</li><li>框架：gRPC、apache dubbo、Spring5</li><li>分布式协调器： ZooKeeper</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
      <category>极客时间</category>
      
      <category>Netty源码剖析与实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>极客时间</tag>
      
      <tag>源码</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极客时间《netty源码剖析与实战》学习笔记2</title>
    <link href="/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h2 id="1-如何切换io模式"><a href="#1-如何切换io模式" class="headerlink" title="1 如何切换io模式"></a><strong>1 如何切换io模式</strong></h2><p>在io.netty.example.echo.EchoServer类中，找到</p><p><img src="https://pic2.zhimg.com/80/v2-3dae64aaab1be8932dfe700454d3c2ad_720w.webp" alt="img"></p><ol><li>OioEventLoopGroup()，将bossGroup和workerGroup的示例切换成其他IO，例如 <code>new OioEventLoopGroup()</code> ，以切换不同的开发模式。<br>&#x2F;&#x2F; 更改这两行，换成想要的IO<br>EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();<br>EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</li><li>在ServerBootstrap中切换channel。切换不同的IO模式</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">ServerBootstrap b = new ServerBootstrap();<br>b.group(bossGroup, workerGroup)<br> .channel(NioServerSocketChannel.class)<br></code></pre></td></tr></table></figure><p>三行解决切换。</p><h3 id="channel方法源码解析"><a href="#channel方法源码解析" class="headerlink" title="channel方法源码解析"></a><strong>channel方法源码解析</strong></h3><p>在channel方法中，是一个反射工厂的实现</p><p><img src="https://pic4.zhimg.com/80/v2-ef8a3ad3cbf910f9122e7d2f1f6d92b3_720w.webp" alt="img"></p><p>下图为ReflectiveChannelFactory的具体实现，这个类实现了ChannelFactory<T>。</p><p>在构造方法中的实参是一个泛型，我们将一个NioServerSocketChannel.class传入，则会获取这个类的无参构造器，然后再newChannel()方法中通过反射创建不同的channel类型。实现IO模式的切换。<strong>泛型+反射+工厂模式实现IO切换</strong></p><p><img src="https://pic1.zhimg.com/80/v2-ab48ac6df1a8501308ced5d8bba7b584_720w.webp" alt="img"></p><h3 id="不需要切换客户端对应的Nio"><a href="#不需要切换客户端对应的Nio" class="headerlink" title="不需要切换客户端对应的Nio"></a><strong>不需要切换客户端对应的Nio</strong></h3><p>在服务器开发中，并不需要切换客户端对应的NioSocketChannel.</p><p>在doReadMessage方法中，实现了accept方法，通过accept方法创建出一个socketChannel。</p><p><img src="https://pic4.zhimg.com/80/v2-c39e67cb5cacca1a83abf6078d83f6c7_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-f3205341049f20fd126117b211978c34_720w.webp" alt="img"></p><h3 id="NioEventLoop是什么？"><a href="#NioEventLoop是什么？" class="headerlink" title="NioEventLoop是什么？"></a><strong>NioEventLoop是什么？</strong></h3><p>NioEventLoop继承SingleThreadEventLoop。将Channel注册到Selector，实现事件循环多路复用。在run方法中，写一个死循环实现selector，负责监听、处理事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//死循环监听、处理事件</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                    <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    select(wakenUp.getAndSet(<span class="hljs-literal">false</span>));<br>                    <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>                        selector.wakeup();<br>                    &#125;<br>                    <span class="hljs-comment">// fall through</span><br>                <span class="hljs-keyword">default</span>:<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-comment">// If we receive an IOException here its because the Selector is messed up. Let&#x27;s rebuild</span><br>                <span class="hljs-comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span><br>                rebuildSelector0();<br>                handleLoopException(e);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            cancelledKeys = <span class="hljs-number">0</span>;<br>            needsToSelectAgain = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ioRatio</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.ioRatio;<br>            <span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    runAllTasks();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioStartTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioTime</span> <span class="hljs-operator">=</span> System.nanoTime() - ioStartTime;<br>                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>        <span class="hljs-comment">// Always handle shutdown even if the loop processing threw an exception.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (isShuttingDown()) &#123;<br>                closeAll();<br>                <span class="hljs-keyword">if</span> (confirmShutdown()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Netty如何支持三种Reactor"><a href="#2-Netty如何支持三种Reactor" class="headerlink" title="2.Netty如何支持三种Reactor"></a><strong>2.Netty如何支持三种Reactor</strong></h2><p>在NIO模式下，所对应的开发模式就是reactor。</p><h3 id="三种reactor"><a href="#三种reactor" class="headerlink" title="三种reactor"></a><strong>三种reactor</strong></h3><ol><li>单线程，一个线程去处理全部事件，容易阻塞。线程挂了系统也挂了。</li></ol><p><img src="https://pic2.zhimg.com/80/v2-479693a68f46a13d73c5e4b38d5a9cb9_720w.webp" alt="img"></p><p>\2. 多线程，将decode compute encode放入线程池进行处理。</p><p><img src="https://pic3.zhimg.com/80/v2-a4f714b10dc66042cbe05597c1d01762_720w.webp" alt="img"></p><p>\3. 主从多线程模式，在服务器开发中，acceptor专门放到一个reactor中。</p><p><img src="https://pic1.zhimg.com/80/v2-b92ac3390dba142dd5c07e496378f8dc_720w.webp" alt="img"></p><h3 id="reactor核心流程"><a href="#reactor核心流程" class="headerlink" title="reactor核心流程"></a><strong>reactor核心流程</strong></h3><p>注册事件-&gt;扫描是否有事件发生-&gt;事件发生后进行处理</p><p><img src="https://pic2.zhimg.com/80/v2-184414c85fcbae94d5084c30f6d676d9_720w.webp" alt="img"></p><h3 id="不同的reactor如何去实现"><a href="#不同的reactor如何去实现" class="headerlink" title="不同的reactor如何去实现"></a><strong>不同的reactor如何去实现</strong></h3><table><thead><tr><th>Reactor 单线程模式</th><th>EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup(1); ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap(); serverBootstrap.group(eventGroup);</th></tr></thead><tbody><tr><td>非主从 Reactor 多线程模式</td><td>EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup(); ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap(); serverBootstrap.group(eventGroup); &#x2F;&#x2F;默认根据cpu的核心数进行new线程。</td></tr><tr><td>主从 Reactor 多线程模式</td><td>EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(); EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup(); ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup);</td></tr></tbody></table><h2 id="3-netty对reactor的常见疑问"><a href="#3-netty对reactor的常见疑问" class="headerlink" title="3.netty对reactor的常见疑问"></a><strong>3.netty对reactor的常见疑问</strong></h2><h3 id="3-1-Netty-如何支持主从-Reactor-模式的？"><a href="#3-1-Netty-如何支持主从-Reactor-模式的？" class="headerlink" title="3.1 Netty 如何支持主从 Reactor 模式的？"></a><strong>3.1 Netty 如何支持主从 Reactor 模式的？</strong></h3><p>在EchoServer中，bossGroup就是main reactor。 workerGroup就是sub Reactor。</p><p><img src="https://pic2.zhimg.com/80/v2-af2d850c62d844f90c87ab40c4f088f5_720w.webp" alt="img"></p><p>serverSocketChannel绑定到bossGroup中，那么serverSocketChannel就会创建childChannel并且绑定到workerGroup中。把两种socketchanner绑定到两个不同的group中，用于支持主从reactor模式。</p><h3 id="3-2-为什么说-Netty-的-main-reactor-大多并不能用到一个线程组，只能线程组里面的一个？"><a href="#3-2-为什么说-Netty-的-main-reactor-大多并不能用到一个线程组，只能线程组里面的一个？" class="headerlink" title="3.2 为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个？"></a><strong>3.2 为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个？</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-11d4193a99916879a4bb46aa7de1ef78_720w.webp" alt="img"></p><p>io.netty.bootstrap.AbstractBootstrap#doBind（）方法里面初始化bossgroup，doBind()方法绑定一个地址和端口，把服务器给启动起来。对于服务器来说，我们一般只会绑定一个地址和一个端口，所以我们只会调用一次线程组的线程。</p><h3 id="3-3-Netty-给-Channel-分配-NIO-event-loop-的规则是什么"><a href="#3-3-Netty-给-Channel-分配-NIO-event-loop-的规则是什么" class="headerlink" title="3.3 Netty 给 Channel 分配 NIO event loop 的规则是什么"></a><strong>3.3 Netty 给 Channel 分配 NIO event loop 的规则是什么</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel) <br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel)</span> &#123;<br>        <span class="hljs-keyword">return</span> next().register(channel);<br>    &#125;<br><br><span class="hljs-comment">//根据待绑定的executor是否是2的幂次方，做出不同的选择</span><br>io.netty.util.concurrent.DefaultEventExecutorChooserFactory#newChooser<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutorChooser <span class="hljs-title function_">newChooser</span><span class="hljs-params">(EventExecutor[] executors)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isPowerOfTwo(executors.length)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span>(executors);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericEventExecutorChooser</span>(executors);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果是2的幂次方，会有一个内部类，实现一个取模运算提升效率。</p><p>注意：这里的下标要保证线程安全，所以使用AtomicInteger的自增。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<br><br>    PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;<br>        <span class="hljs-built_in">this</span>.executors = executors;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//executors总数必须是2的幂次方（2，4，8...等）才会用,&amp;运算效率更高,同时当idx累加成最大值之后，相比较通用的方式（GenericEventExecutorChooser），更公平</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不是二的倍数，使用默认方法，递增-&gt;取模-&gt;取绝对值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<br><br>    GenericEventExecutorChooser(EventExecutor[] executors) &#123;<br>        <span class="hljs-built_in">this</span>.executors = executors;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//递增、取模，取正值，不然可能是负数，另外：有个非常小的缺点，当idx累加成最大值后，有短暂的不公平：</span><br>        <span class="hljs-comment">//1，2，3，4，5，6，7，0，7（注意这里不是1，而是7，然而往前的第二个也是7，所以不够公平），6，5</span><br>        <span class="hljs-keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-通用模式的-NIO-实现多路复用器是怎么跨平台的"><a href="#3-4-通用模式的-NIO-实现多路复用器是怎么跨平台的" class="headerlink" title="3.4 通用模式的 NIO 实现多路复用器是怎么跨平台的"></a><strong>3.4 通用模式的 NIO 实现多路复用器是怎么跨平台的</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.channel.nio.NioEventLoopGroup#NioEventLoopGroup(<span class="hljs-type">int</span>, java.util.concurrent.Executor)   <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor)</span> &#123;<br>        <span class="hljs-comment">//默认selector,最终实现类似：https://github.com/frohoff/jdk8u-jdk/blob/master/src/macosx/classes/sun/nio/ch/DefaultSelectorProvider.java</span><br>        <span class="hljs-comment">//basic flow: 1 java.nio.channels.spi.SelectorProvider 2 META-INF/services 3 default</span><br>        <span class="hljs-built_in">this</span>(nThreads, executor, SelectorProvider.provider());<br>    &#125;<br><br>java.nio.channels.spi.SelectorProvider#provider<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SelectorProvider <span class="hljs-title function_">provider</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">if</span> (provider != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> provider;<br>            <span class="hljs-keyword">return</span> AccessController.doPrivileged(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;SelectorProvider&gt;() &#123;<br>                    <span class="hljs-keyword">public</span> SelectorProvider <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                           ........<br>                            provider = sun.nio.ch.DefaultSelectorProvider.create(); <span class="hljs-comment">//调用不同平台下的创建方法进行创建</span><br>                            <span class="hljs-keyword">return</span> provider;<br>                        &#125;<br>                    &#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SelectorProvider <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KQueueSelectorProvider</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4-TCP粘包、半包"><a href="#4-TCP粘包、半包" class="headerlink" title="4.TCP粘包、半包"></a><strong>4.TCP粘包、半包</strong></h2><h3 id="什么是粘包和半包？"><a href="#什么是粘包和半包？" class="headerlink" title="什么是粘包和半包？"></a><strong>什么是粘包和半包？</strong></h3><p>abc \n def -&gt; a bcd\nef</p><p>想要发送的是两段信息分别是abc和def中间由\n分隔。在传输过后，先接受到a，再接收到bcd\nef。那么先接收到的a就是半包（没接收完整），后面接收到的 “bcd \n ef”，就是粘包。</p><h3 id="为什么TCP应用中会出现粘包和半包现象？"><a href="#为什么TCP应用中会出现粘包和半包现象？" class="headerlink" title="为什么TCP应用中会出现粘包和半包现象？"></a><strong>为什么TCP应用中会出现粘包和半包现象？</strong></h3><h3 id="粘包的主要原因："><a href="#粘包的主要原因：" class="headerlink" title="粘包的主要原因："></a><strong>粘包的主要原因：</strong></h3><ul><li>发送方每次写入数据 &lt; 套接字缓冲区大小</li><li>接收方读取套接字缓冲区不够及时</li></ul><h3 id="半包："><a href="#半包：" class="headerlink" title="半包："></a><strong>半包：</strong></h3><ul><li>发送方写入数据 &gt; 套接字缓冲区大小</li><li>发送的数据大于协议的MTU（最大传输单元），必须拆包</li></ul><h3 id="从收发传输的角度看："><a href="#从收发传输的角度看：" class="headerlink" title="从收发传输的角度看："></a><strong>从收发传输的角度看：</strong></h3><ul><li>一个发送可能被多次接收，多个发送可能被一次接收（缓冲区）</li><li>一个发送占用了多个传输包，多个发送可能占用一个传输包</li></ul><p><strong>问题的根本原因：TCP没有消息边界</strong></p><h3 id="解决沾包和半包问题的几种常用方法"><a href="#解决沾包和半包问题的几种常用方法" class="headerlink" title="解决沾包和半包问题的几种常用方法"></a><strong>解决沾包和半包问题的几种常用方法</strong></h3><p><strong>解决手段：找出消息边界</strong></p><p><img src="https://pic4.zhimg.com/80/v2-92af5693be90621266c531186492a22b_720w.webp" alt="img"></p><h3 id="Netty对三种常用封帧方式的支持"><a href="#Netty对三种常用封帧方式的支持" class="headerlink" title="Netty对三种常用封帧方式的支持"></a><strong>Netty对三种常用封帧方式的支持</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-1576feaecc2bfe3cadb44432d0d3c639_720w.webp" alt="img"></p><h2 id="解读Netty处理粘包、半包的源码"><a href="#解读Netty处理粘包、半包的源码" class="headerlink" title="解读Netty处理粘包、半包的源码"></a><strong>解读Netty处理粘包、半包的源码</strong></h2><h3 id="解码核心工作流程"><a href="#解码核心工作流程" class="headerlink" title="解码核心工作流程"></a><strong>解码核心工作流程</strong></h3><p>解码入口方法：io.netty.handler.codec.ByteToMessageDecoder#channelRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//参数msg就是传入的数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ByteBuf) &#123;<br>        <span class="hljs-type">CodecOutputList</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> CodecOutputList.newInstance();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//要解析的数据首先转化为data</span><br>            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>            first = cumulation == <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//如果是第一笔数据，就赋值给cumulation数据积累器，也就是在解码前或者解码后都是一个数据积累的过程</span><br>            <span class="hljs-keyword">if</span> (first) &#123;<br>                cumulation = data;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果不是第一笔数据，就追加到cumulation，采用的是策略模式</span><br>                cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);<br>            &#125;<br>            callDecode(ctx, cumulation, out);<br>        &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (cumulation != <span class="hljs-literal">null</span> &amp;&amp; !cumulation.isReadable()) &#123;<br>                numReads = <span class="hljs-number">0</span>;<br>                cumulation.release();<br>                cumulation = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++ numReads &gt;= discardAfterReads) &#123;<br>                <span class="hljs-comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/4275</span><br>                numReads = <span class="hljs-number">0</span>;<br>                discardSomeReadBytes();<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> out.size();<br>            decodeWasNull = !out.insertSinceRecycled();<br>            fireChannelRead(ctx, out, size);<br>            out.recycle();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ctx.fireChannelRead(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数msg就是传入的数据,要解析的数据首先转化为data. 如果是第一笔数据，就赋值给cumulation数据积累器，也就是在解码前或者解码后都是一个数据积累的过程;如果不是第一笔数据，就追加到cumulation，采用的是策略模式。 接着调用callDecode解码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callDecode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//参数in就是数据积累器的数据</span><br>        <span class="hljs-keyword">while</span> (in.isReadable()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">outSize</span> <span class="hljs-operator">=</span> out.size();<br><br>            <span class="hljs-keyword">if</span> (outSize &gt; <span class="hljs-number">0</span>) &#123;<br>                fireChannelRead(ctx, out, outSize);<br>                out.clear();<br><br>                <span class="hljs-comment">// Check if this handler was removed before continuing with decoding.</span><br>                <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See:</span><br>                <span class="hljs-comment">// - https://github.com/netty/netty/issues/4635</span><br>                <span class="hljs-keyword">if</span> (ctx.isRemoved()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                outSize = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">oldInputLength</span> <span class="hljs-operator">=</span> in.readableBytes();<br>            decodeRemovalReentryProtection(ctx, in, out);<br><br>            <span class="hljs-comment">// Check if this handler was removed before continuing the loop.</span><br>            <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/1664</span><br>            <span class="hljs-keyword">if</span> (ctx.isRemoved()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (outSize == out.size()) &#123;<br>                <span class="hljs-keyword">if</span> (oldInputLength == in.readableBytes()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (oldInputLength == in.readableBytes()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(<br>                        StringUtil.simpleClassName(getClass()) +<br>                                <span class="hljs-string">&quot;.decode() did not read anything but decoded a message.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (isSingleDecode()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception cause) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数in就是数据积累器的数据，也就是我们收到的数据，第一次outSize大小肯定为0，所以跳过if语句，然后会调用decodeRemovalReentryProtection（）方法。该方法作用是：在decode中时，是不能执行handler remove清理操作的，在decode完之后需要清理数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decodeRemovalReentryProtection</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    decodeState = STATE_CALLING_CHILD_DECODE;<br>    <span class="hljs-keyword">try</span> &#123;<br>        decode(ctx, in, out);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removePending</span> <span class="hljs-operator">=</span> decodeState == STATE_HANDLER_REMOVED_PENDING;<br>        decodeState = STATE_INIT;<br>        <span class="hljs-keyword">if</span> (removePending) &#123;<br>            handlerRemoved(ctx);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内部会调用decode方法，该方法采用的是模版方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception;<br></code></pre></td></tr></table></figure><p>可以查询子类FixedLengthFrameDecoder，此时就完成一次数据解析的流程。 通过下面的代码就可以发现，处理了粘包和半包的问题。 在编码数据前，先对数据进行积累Cumulator。解码的时候先判断是否小于固定的长度，小的话就是包不全也就不去解码数据，等于的话就直接解(没问题)，大于的话就解对应长度的，多的那部分还是在积累器里面，等下次用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">decode</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@SuppressWarnings(&quot;UnusedParameters&quot;)</span> ChannelHandlerContext ctx, ByteBuf in)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (in.readableBytes() &lt; frameLength) &#123;<span class="hljs-comment">//处理半包的问题</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//处理粘包的问题，多余的数据还会存储在accumation中</span><br>        <span class="hljs-keyword">return</span> in.readRetainedSlice(frameLength);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解码中两种数据积累器的区别"><a href="#解码中两种数据积累器的区别" class="headerlink" title="解码中两种数据积累器的区别"></a><strong>解码中两种数据积累器的区别</strong></h3><h3 id="MERGE-CUMULATOR"><a href="#MERGE-CUMULATOR" class="headerlink" title="MERGE_CUMULATOR"></a><strong>MERGE_CUMULATOR</strong></h3><p>using memory copies</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Cumulator</span> <span class="hljs-variable">MERGE_CUMULATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cumulator</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">cumulate</span><span class="hljs-params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> &#123;<br>        <span class="hljs-keyword">final</span> ByteBuf buffer;<br>        <span class="hljs-comment">//如果容量不够就扩容</span><br>        <span class="hljs-keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()<br>                || cumulation.refCnt() &gt; <span class="hljs-number">1</span> || cumulation.isReadOnly()) &#123;<br>            <span class="hljs-comment">// Expand cumulation (by replace it) when either there is not more room in the buffer</span><br>            <span class="hljs-comment">// or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</span><br>            <span class="hljs-comment">// duplicate().retain() or if its read-only.</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See:</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/2327</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/1764</span><br>            buffer = expandCumulation(alloc, cumulation, in.readableBytes());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            buffer = cumulation;<br>        &#125;<br>        <span class="hljs-comment">//如果容量足够的话，就直接把数据追加进去</span><br>        buffer.writeBytes(in);<br>        in.release();<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="COMPOSITE-CUMULATOR"><a href="#COMPOSITE-CUMULATOR" class="headerlink" title="COMPOSITE_CUMULATOR"></a><strong>COMPOSITE_CUMULATOR</strong></h3><ul><li>ByteBuf通过将它们添加到 CompositeByteBuf 来累积，因此尽可能不复制内存。请注意，使用更复杂的索引实现，CompositeByteBuf因此根据您的用例和解码器实现，这可能会更慢，然后只使用 MERGE_CUMULATOR。</li><li>不是真正的复制，而是提供一个逻辑的视图，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Cumulator</span> <span class="hljs-variable">COMPOSITE_CUMULATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cumulator</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">cumulate</span><span class="hljs-params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> &#123;<br>        ByteBuf buffer;<br>        <span class="hljs-keyword">if</span> (cumulation.refCnt() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the user</span><br>            <span class="hljs-comment">// use slice().retain() or duplicate().retain().</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See:</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/2327</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/1764</span><br>            buffer = expandCumulation(alloc, cumulation, in.readableBytes());<br>            buffer.writeBytes(in);<br>            in.release();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            CompositeByteBuf composite;<br>            <span class="hljs-comment">//创建compositeByteBuf</span><br>            <span class="hljs-keyword">if</span> (cumulation <span class="hljs-keyword">instanceof</span> CompositeByteBuf) &#123;<br>                composite = (CompositeByteBuf) cumulation;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                composite = alloc.compositeBuffer(Integer.MAX_VALUE);<br>                composite.addComponent(<span class="hljs-literal">true</span>, cumulation);<br>            &#125;<br>            <span class="hljs-comment">//避免内存复制</span><br>            composite.addComponent(<span class="hljs-literal">true</span>, in);<br>            buffer = composite;<br>        &#125;<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>MERGE_CUMULATOR是通过copy实现，实际操作的是ByteBuf；COMPOSITE_CUMULATOR操作的CompositeByteBuf可以看做是对ByteBuf的封装，其维护了一个ByteBuf的List列表，每次cumulate操作其实把当前的ByteBuf放到List中。</p><p>我认为这两种cumulate的性能侧重点不同，merge方式提前copy，那么读取时会更快，反之，使用composite的方式在读取时需要遍历List，读取数据时更慢。</p><p>我觉得使用哪种数据累计器主要看decode实现，如果decode的实现包含很多随机读（比如读取第4-8个字节这种），这种情况肯定是基于复制的Cumulator更好，因为复制方式是连续内存，随机读时间复杂度为O(1), 而组合方式是基于数组实现，由于不确定目标内容在数组的位置，所以 需要遍历数组，效率偏低。</p><h3 id="数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？"><a href="#数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？" class="headerlink" title="数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？"></a><strong>数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？</strong></h3><p>因为组合的方式没有经过充分的证明：证明在所有场景下肯定比内存复制的性能要好（毕竟组合方式的指针维护复杂些，如果解码是把组合的直接能拆出来就可以用，那明显会好，例如ssl hanlder里面就有显示设置为组合方式的例子，但是大多不是如此用，仅有的测试也只是表明好一点点而已)，所以自然默认就还是用原始的那种方式，而不是直接切换到后来加的组合方式，另外提供了setCumulator方法让我们有切换的选择。 总结下：不是说1+1不等于2，而是说大家都这么觉得，但是没有人去有力的证明，所以保持怀疑的态度，就保守起见了，没有改默认的。</p><h3 id="三种解码器的常用额外控制参数有哪些"><a href="#三种解码器的常用额外控制参数有哪些" class="headerlink" title="三种解码器的常用额外控制参数有哪些"></a><strong>三种解码器的常用额外控制参数有哪些</strong></h3><table><thead><tr><th>解码器</th><th>变量</th><th></th></tr></thead><tbody><tr><td>FixedLengthFrameDecoder（固定长度解码器）</td><td>frameLength：指定固定的消息长度。 maxFrameLength：可选参数，用于限制解码的帧的最大长度。 lengthFieldOffset、lengthFieldLength、lengthAdjustment、initialBytesToStrip：这些参数用于处理消息中的长度字段，通常用于半包处理。</td><td>支持多种分隔符</td></tr><tr><td>DelimiterBasedFrameDecoder（分隔符解码器）</td><td>maxFrameLength：指定解码的帧的最大长度。 stripDelimiter：指定是否从解码的帧中删除分隔符。 failFast：可选参数，用于控制是否快速失败（即在遇到无效分隔符时立即抛出异常）。</td><td>指定长度</td></tr><tr><td>LengthFieldBasedFrameDecoder（长度字段解码器）</td><td>maxFrameLength：帧的最大长度，超过此长度将抛出 TooLongFrameException异常。 lengthFieldOffset：长度字段的偏移量。 lengthFieldLength：长度字段的长度。 lengthAdjustment：长度字段的补偿值，用于调整帧的长度。 initialBytesToStrip：从解码帧中跳过的前几个字节的数量。 failFast：如果为 true，当解码器注意到帧的长度将超过 maxFrameLength 时立即抛出 TooLongFrameException 异常；如果为 false，在完全读取超过 maxFrameLength 的帧后再抛出异常。</td><td>根据消息中长度字段的值动态拆分接收到的ByteBuf</td></tr></tbody></table><h2 id="5-常用的“二次”编解码方式"><a href="#5-常用的“二次”编解码方式" class="headerlink" title="5.常用的“二次”编解码方式"></a><strong>5.常用的“二次”编解码方式</strong></h2><h3 id="为什么需要二次解码"><a href="#为什么需要二次解码" class="headerlink" title="为什么需要二次解码"></a><strong>为什么需要二次解码</strong></h3><ul><li><p>一次解码器：ByteToMessageDecoder</p></li><li><ul><li>io.netty.buffer.ByteBuf （原始数据流）-&gt; io.netty.buffer.ByteBuf （用户数据）</li></ul></li><li><p>二次解码器：MessageToMessageDecoder</p></li><li><ul><li>io.netty.buffer.ByteBuf （用户数据）-&gt; Java Object</li></ul></li></ul><p>为了分层和降低耦合性，不建议将两次解码合并成一次。</p><h3 id="常用的二次编解码方式"><a href="#常用的二次编解码方式" class="headerlink" title="常用的二次编解码方式"></a><strong>常用的二次编解码方式</strong></h3><p>Java序列号、XML、JSON、Protobuf、MessagePack</p><h3 id="选择编解码方式的要点"><a href="#选择编解码方式的要点" class="headerlink" title="选择编解码方式的要点"></a><strong>选择编解码方式的要点</strong></h3><ol><li>编码后的占用空间大小</li><li>编解码速度</li><li>可读性</li><li>多语言支持</li></ol><h3 id="Protobuf简介与使用"><a href="#Protobuf简介与使用" class="headerlink" title="Protobuf简介与使用"></a><strong>Protobuf简介与使用</strong></h3><ul><li>Protobuf 是一个灵活的、高效的用于序列化数据的协议</li><li>相比较 XML 和 JSON 格式，Protobuf 更小、更快、更便捷。</li><li>Protobuf 是跨语言的，并且自带了一个编译器（protoc），只需要用它进行编译，可 以自动生成 Java、python、C++ 等代码，不需要再写其他代码</li></ul><h2 id="Netty对二次编解码的支持"><a href="#Netty对二次编解码的支持" class="headerlink" title="Netty对二次编解码的支持"></a><strong>Netty对二次编解码的支持</strong></h2><p>以WorldClockClientInitializer中的initChannel方法为例，说明netty是如何进行二次编解码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.example.worldclock.WorldClockClientInitializer<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>    <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ch.pipeline();<br>    <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//添加一个 SSL 处理器到管道中，用于处理安全连接</span><br>        p.addLast(sslCtx.newHandler(ch.alloc(), WorldClockClient.HOST, WorldClockClient.PORT));<br>    &#125;<br><br>    <span class="hljs-comment">//一次解码 得到一个bytebuf</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufVarint32FrameDecoder</span>());<br>    <span class="hljs-comment">//二次解码 得到一个object</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufDecoder</span>(WorldClockProtocol.LocalTimes.getDefaultInstance()));<br><br>    <span class="hljs-comment">//一次编码 解决粘包和半包问题</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufVarint32LengthFieldPrepender</span>());<br>    <span class="hljs-comment">//二次编码 字节数组</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufEncoder</span>());<br><br>    <span class="hljs-comment">//业务流程</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WorldClockClientHandler</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一次解码"><a href="#一次解码" class="headerlink" title="一次解码"></a><strong>一次解码</strong></h3><ul><li>第一次解码：<strong>ProtobufVarint32FrameDecoder</strong> 目的是将具体内容拆分出来，得到一个bytebuf</li></ul><p>Varint &#x3D; 长度字段的长度可变： 值越小的数字使用越少的字节数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">BEFORE <span class="hljs-title function_">DECODE</span> <span class="hljs-params">(<span class="hljs-number">302</span> bytes)</span>       AFTER <span class="hljs-title function_">DECODE</span> <span class="hljs-params">(<span class="hljs-number">300</span> bytes)</span><br>+--------+---------------+      +---------------+<br>| Length | Protobuf Data |-----&gt;| Protobuf Data |<br>| <span class="hljs-number">0xAC02</span> |  (<span class="hljs-number">300</span> bytes)  |      |  (<span class="hljs-number">300</span> bytes)  |<br>+--------+---------------+      +---------------+<br></code></pre></td></tr></table></figure><h3 id="二次解码"><a href="#二次解码" class="headerlink" title="二次解码"></a><strong>二次解码</strong></h3><ul><li>第二次解码：<strong>ProtobufDecoder</strong> 目的是对protobuf中的信息进行具体的处理，得到一个java object<br>在decode方法中，会对传入的bytebuf进行不同情况的处理，先判断是否有extension再判断是否存在HAS_PARSER。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] array;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> offset;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> msg.readableBytes();<br>    <span class="hljs-keyword">if</span> (msg.hasArray()) &#123;<br>        array = msg.array();<br>        offset = msg.arrayOffset() + msg.readerIndex();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        array = ByteBufUtil.getBytes(msg, msg.readerIndex(), length, <span class="hljs-literal">false</span>);<br>        offset = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//带extension 扩展</span><br>    <span class="hljs-keyword">if</span> (extensionRegistry == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//HAS_PARSER when &gt;protobuf 2.5.0</span><br>        <span class="hljs-keyword">if</span> (HAS_PARSER) &#123;<br>            out.add(prototype.getParserForType().parseFrom(array, offset, length));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            out.add(prototype.newBuilderForType().mergeFrom(array, offset, length).build());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (HAS_PARSER) &#123;<br>            out.add(prototype.getParserForType().parseFrom(<br>                    array, offset, length, extensionRegistry));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            out.add(prototype.newBuilderForType().mergeFrom(<br>                    array, offset, length, extensionRegistry).build());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一次编码"><a href="#一次编码" class="headerlink" title="一次编码"></a><strong>一次编码</strong></h3><ul><li>第一次编码：<strong>ProtobufVarint32LengthFieldPrepender</strong>，解决粘包和半包问题。在编码的头部加入length字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">BEFORE <span class="hljs-title function_">ENCODE</span> <span class="hljs-params">(<span class="hljs-number">300</span> bytes)</span>       AFTER <span class="hljs-title function_">ENCODE</span> <span class="hljs-params">(<span class="hljs-number">302</span> bytes)</span><br>+---------------+               +--------+---------------+<br>| Protobuf Data |--------------&gt;| Length | Protobuf Data |<br>|  (<span class="hljs-number">300</span> bytes)  |               | <span class="hljs-number">0xAC02</span> |  (<span class="hljs-number">300</span> bytes)  |<br>+---------------+               +--------+---------------+<br></code></pre></td></tr></table></figure><p>为了实现高性能，还会对不同长度的length进行位运算，以达到使用最少的字节数表达长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">computeRawVarint32Size</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-comment">//根据不同的值返回不同的字节数</span><br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt;  <span class="hljs-number">7</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">14</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">21</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">28</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二次编码"><a href="#二次编码" class="headerlink" title="二次编码"></a><strong>二次编码</strong></h3><ul><li>第二次编码：<strong>ProtobufEncoder</strong> 得到一个字节数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageLiteOrBuilder msg, List&lt;Object&gt; out)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> MessageLite) &#123;<br>        out.add(wrappedBuffer(((MessageLite) msg).toByteArray()));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> MessageLite.Builder) &#123;<br>        out.add(wrappedBuffer(((MessageLite.Builder) msg).build().toByteArray()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Keepalive与idle监测"><a href="#6-Keepalive与idle监测" class="headerlink" title="6.Keepalive与idle监测"></a><strong>6.Keepalive与idle监测</strong></h2><h3 id="为什么要keepalive"><a href="#为什么要keepalive" class="headerlink" title="为什么要keepalive"></a><strong>为什么要keepalive</strong></h3><p>在双方进行通话时，如何对方不讲话了，我们需要问一句“你还在吗？”如果对方没有回复，挂机。这套机制就是keepalive。</p><p><img src="https://pic4.zhimg.com/80/v2-478dfdbf49fb7236f1eed3c3e8c4034f_720w.webp" alt="img"></p><h3 id="怎么设计keepalive？以TCP-keepalive为例"><a href="#怎么设计keepalive？以TCP-keepalive为例" class="headerlink" title="怎么设计keepalive？以TCP keepalive为例"></a><strong>怎么设计keepalive？以TCP keepalive为例</strong></h3><p>TCP keepalive核心参数：</p><blockquote><p>net.ipv4.tcp_keepalive_time &#x3D; 7200 &#x2F;&#x2F;出现问题概率小，没有必要频繁<br>net.ipv4.tcp_keepalive_intvl &#x3D; 75<br>net.ipv4.tcp_keepalive_probes &#x3D; 9 &#x2F;&#x2F;谨慎判断</p></blockquote><p>当启用（默认关闭）keepalive时，TCP在没有数据通过的7200秒后发送keepalive消息，当探测没有确认时，按75秒的重试评论重发，一直法9个探测包都没有确认，就认为连接失败，则关闭连接。</p><p>总耗时 7200+75*9 &#x3D; 2h 11min</p><h3 id="为什么还需要应用层keepalive"><a href="#为什么还需要应用层keepalive" class="headerlink" title="为什么还需要应用层keepalive"></a><strong>为什么还需要应用层keepalive</strong></h3><ul><li>TCP层的keepalive默认关闭 ，而且经过路由等中转设备可能会被丢弃。</li><li>keepalive时间太长（默认&gt;2h），虽然可以改，但是必须要改动所有应用</li><li>各层协议关注点不同。传输层关注是否连接通常，应用层关注是否可服务。电话通了并不代表有人接。</li></ul><p>应用层的keepalive长连接在HTTP1里面有header。HTTP&#x2F;1.1默认是长连接，所以没有这个header</p><h3 id="Idle监测是什么"><a href="#Idle监测是什么" class="headerlink" title="Idle监测是什么"></a><strong>Idle监测是什么</strong></h3><p>在通话场景中，如果对方突然不说话了。那么我们会稍微等待一段时间，看看这个时间内对方还会不会说话（idle），如何还不说，就认为对方存在问题（idle），于是开始发问“你还在吗”（keepalive），或者直接挂机（关闭连接）。</p><ul><li><p>Idle监测只是负责诊断，做出不同的行为后，觉得Idle的最终用途。</p></li><li><p>发送keepalive：<br><strong>keepalive演进</strong></p></li><li><ul><li>v1：定时发送消息（消耗太大）</li><li>v2：有其他数据传输（业务），不发送keepalive。没有数据传输，判定为Idle,再发送keepalive。</li></ul></li><li><p>直接关闭连接</p></li><li><ul><li>快速释放损坏，恶意、不使用的连接</li><li>客户端重连。</li></ul></li></ul><h3 id="如何在Netty中开启TCP-keepalive和Idle监测"><a href="#如何在Netty中开启TCP-keepalive和Idle监测" class="headerlink" title="如何在Netty中开启TCP keepalive和Idle监测"></a><strong>如何在Netty中开启TCP keepalive和Idle监测</strong></h3><h3 id="开启两种风格的keepalive"><a href="#开启两种风格的keepalive" class="headerlink" title="开启两种风格的keepalive"></a><strong>开启两种风格的keepalive</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">.childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>.childOption(NioChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>提示：.option(ChannelOption.SO_KEEPALIVE,true) 存在但是无效</p><h3 id="开启不同的Idle-Check："><a href="#开启不同的Idle-Check：" class="headerlink" title="开启不同的Idle Check："></a><strong>开启不同的Idle Check：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(“idleCheckHandler<span class="hljs-string">&quot;, new IdleStateHandler(0, 20, 0, TimeUnit.SECONDS));</span><br><span class="hljs-string">//----------------------//</span><br><span class="hljs-string">public IdleStateHandler(</span><br><span class="hljs-string">        long readerIdleTime, long writerIdleTime, long allIdleTime,</span><br><span class="hljs-string">        TimeUnit unit) &#123;</span><br><span class="hljs-string">    this(false, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="源码解读Netty对TCP-keepalive和三种Idle监测的支持"><a href="#源码解读Netty对TCP-keepalive和三种Idle监测的支持" class="headerlink" title="源码解读Netty对TCP keepalive和三种Idle监测的支持"></a><strong>源码解读Netty对TCP keepalive和三种Idle监测的支持</strong></h2><h3 id="设置TCP-keepalive怎么生效"><a href="#设置TCP-keepalive怎么生效" class="headerlink" title="设置TCP keepalive怎么生效"></a><strong>设置TCP keepalive怎么生效</strong></h3><p>以EchoServer为例，从设置keepalive的childOption方法进入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. io.netty.bootstrap.ServerBootstrap<span class="hljs-comment">#childOption  </span><br>2.   -&gt; io.netty.bootstrap.ServerBootstrap<span class="hljs-comment">#init  </span><br>3.      -&gt; io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor<span class="hljs-comment">#ServerBootstrapAcceptor  </span><br>4.         -&gt; io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor<span class="hljs-comment">#channelRead</span><br>5.            -&gt; io.netty.bootstrap.AbstractBootstrap<span class="hljs-comment">#setChannelOptions  </span><br>6.              -&gt;io.netty.bootstrap.AbstractBootstrap<span class="hljs-comment">#setChannelOption  </span><br>7.                -&gt; io.netty.channel.socket.nio.NioSocketChannel.NioSocketChannelConfig<span class="hljs-comment">#setOption</span><br></code></pre></td></tr></table></figure><p>1.传入一个普通的channel而不是传入一个serverSocketChannel，在childOption()方法中，对成员变量childOptions进行了设置，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;ChannelOption&lt;?&gt;, Object&gt;();<br></code></pre></td></tr></table></figure><p>2.成员变量childOptions在init()方法中被转化为currentChildOptions。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>ChannelInitializer一次性、初始化handler: 负责添加一个ServerBootstrapAcceptor handler，添加完后，自己就移除了: ServerBootstrapAcceptor handler： 负责接收客户端连接创建连接后，对连接的初始化工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.bootstrap.ServerBootstrap#init <br>    <br>p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>        <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>        <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>            pipeline.addLast(handler);<br>        &#125;<br><br>        ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>3.io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#ServerBootstrapAcceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerBootstrapAcceptor(<span class="hljs-comment">//接受连接后的后续处理</span><br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>4.对于上面的ServerBootstrapAcceptor的后续处理由channelRead()方法进行处理。<strong>将childOption设置到Channel里面去</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (Channel) msg;  <span class="hljs-comment">//msg是一个channel</span><br>    child.pipeline().addLast(childHandler);<br>    setChannelOptions(child, childOptions, logger); <span class="hljs-comment">//设置childOption</span><br>    setAttributes(child, childAttrs);<br>        ......<br>&#125;<br></code></pre></td></tr></table></figure><p>5.io.netty.bootstrap.AbstractBootstrap#setChannelOptions<br>static void setChannelOptions<br>setChannelOption(channel, e.getKey(), e.getValue(), logger);</p><p>6 -&gt; 7.</p><p>7.直到第七步可以看见接口有许多实现类，选择NioSocketChannel，可以看见由nio方式实现的设置keepalive方法。同时，在DefaultChannelConfig中实现了另一种设置keepalive的方式。</p><h3 id="两种设置keepalive的方式有什么区别？"><a href="#两种设置keepalive的方式有什么区别？" class="headerlink" title="两种设置keepalive的方式有什么区别？"></a><strong>两种设置keepalive的方式有什么区别？</strong></h3><ul><li><strong>io.netty.channel.socket.nio.NioSocketChannel</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置指定的选项到指定的 JDK 原生 Channel。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> jdkChannel JDK 原生 Channel</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> option     NioChannelOption 选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value      选项值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;        选项类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果设置成功，则返回 true；否则返回 false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">setOption</span><span class="hljs-params">(Channel jdkChannel, NioChannelOption&lt;T&gt; option, T value)</span> &#123;<br>    <span class="hljs-comment">// 将 JDK 原生 Channel 转换为 NetworkChannel 类型</span><br>    java.nio.channels.<span class="hljs-type">NetworkChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (java.nio.channels.NetworkChannel) jdkChannel;<br><br>    <span class="hljs-comment">// 检查通道是否支持指定的选项</span><br>    <span class="hljs-keyword">if</span> (!channel.supportedOptions().contains(option.option)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果是 ServerSocketChannel 并且选项是 IP_TOS，则跳过设置，作为 JDK bug 的解决方法</span><br>    <span class="hljs-keyword">if</span> (channel <span class="hljs-keyword">instanceof</span> ServerSocketChannel &amp;&amp; option.option == java.net.StandardSocketOptions.IP_TOS) &#123;<br>        <span class="hljs-comment">// 跳过 IP_TOS 选项</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 设置选项到 JDK 原生 Channel</span><br>        channel.setOption(option.option, value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-comment">// 发生异常时，抛出 ChannelException</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>io.netty.channel.socket.nio.DefaultChannelConfig</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置通道选项到 Netty Channel。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> option 选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value  选项值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;    选项类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果设置成功，则返回 true；否则返回 false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">setOption</span><span class="hljs-params">(ChannelOption&lt;T&gt; option, T value)</span> &#123;<br>    <span class="hljs-comment">// 验证选项和值是否有效</span><br>    validate(option, value);<br><br>    <span class="hljs-comment">// 根据选项类型执行相应的设置操作</span><br>    <span class="hljs-keyword">if</span> (option == SO_RCVBUF) &#123;<br>        <span class="hljs-comment">// 设置接收缓冲区大小</span><br>        setReceiveBufferSize((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_SNDBUF) &#123;<br>        <span class="hljs-comment">// 设置发送缓冲区大小</span><br>        setSendBufferSize((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == TCP_NODELAY) &#123;<br>        <span class="hljs-comment">// 设置 TCP_NODELAY</span><br>        setTcpNoDelay((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_KEEPALIVE) &#123;<br>        <span class="hljs-comment">// 设置 SO_KEEPALIVE</span><br>        setKeepAlive((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_REUSEADDR) &#123;<br>        <span class="hljs-comment">// 设置 SO_REUSEADDR</span><br>        setReuseAddress((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_LINGER) &#123;<br>        <span class="hljs-comment">// 设置 SO_LINGER</span><br>        setSoLinger((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == IP_TOS) &#123;<br>        <span class="hljs-comment">// 设置 IP_TOS</span><br>        setTrafficClass((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == ALLOW_HALF_CLOSURE) &#123;<br>        <span class="hljs-comment">// 设置 ALLOW_HALF_CLOSURE</span><br>        setAllowHalfClosure((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 调用父类的 setOption() 方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setOption(option, value);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法分别是<code>Netty</code>框架中的两个不同类中的方法，用于设置通道选项。</p><p><code>setOption(Channel jdkChannel, NioChannelOption&lt;T&gt; option, T value)</code>方法是一个静态方法，用于设置指定的选项到指定的<code>JDK</code>原生<code>Channel</code>。</p><p><code>setOption(ChannelOption&lt;T&gt; option, T value)</code>方法是<code>Channel</code>类的实例方法，用于设置通道选项到<code>Netty</code>的<code>Channel</code>中。</p><p>这两个方法的区别在于，<code>setOption(Channel jdkChannel, NioChannelOption&lt;T&gt; option, T value)</code>方法是用于设置<code>JDK</code>原生<code>Channel</code>的选项，而<code>setOption(ChannelOption&lt;T&gt; option, T value)</code>方法是用于设置<code>Netty</code>的<code>Channel</code>的选项。</p><p>从代码可扩展性来看nio中的方法显然更容易添加和修改，而默认方式很多if&#x2F;else的情况下，如果要修改一个，就会牵一发而动全身。</p><h3 id="Idle检测类包（io-netty-handler-timeout）的功能有哪些"><a href="#Idle检测类包（io-netty-handler-timeout）的功能有哪些" class="headerlink" title="Idle检测类包（io.netty.handler.timeout）的功能有哪些"></a><strong>Idle检测类包（io.netty.handler.timeout）的功能有哪些</strong></h3><p>位置在handler模块下的timeout包</p><p><img src="https://pic3.zhimg.com/80/v2-bdaf9058a99f6b15f44152b9d08d8002_720w.webp" alt="img"></p><h3 id="三种类型Idle"><a href="#三种类型Idle" class="headerlink" title="三种类型Idle"></a>三种类型Idle</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">public enum IdleState &#123;<br> /**<br> * 当在指定时间段内未执行读取时，将触发状态为IdleState.READER_IDLE的IdleStateEvent 。指定0以禁用<br> */<br> READER_IDLE,<br> /**<br> * 当在指定的时间段内没有执行写入时，将触发状态为IdleState.WRITER_IDLE的IdleStateEvent 。指定0以禁用。<br> */<br> WRITER_IDLE,<br> /**<br> * 状态为IdleState.ALL_IDLE的IdleStateEvent将在指定时间段内未执行读取或写入时触发。指定0以禁用。<br> */<br> ALL_IDLE<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>六个Idle状态，分别为第一次和非第一次</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">public class IdleStateEvent &#123;<br>    public static final IdleStateEvent FIRST_READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, true);<br>    public static final IdleStateEvent READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, false);<br>    public static final IdleStateEvent FIRST_WRITER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.WRITER_IDLE, true);<br>    public static final IdleStateEvent WRITER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.WRITER_IDLE, false);<br>    public static final IdleStateEvent FIRST_ALL_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.ALL_IDLE, true);<br>    public static final IdleStateEvent ALL_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.ALL_IDLE, false);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读Idle检测的原理"><a href="#读Idle检测的原理" class="headerlink" title="读Idle检测的原理"></a>读Idle检测的原理</h3><p>读取空闲的监测是通过 <code>IdleStateHandler</code> 和事件触发机制实现的。</p><blockquote><p>用“读”是否超时进行判断</p></blockquote><p><code>IdleStateHandler</code> 是一个用于检测连接空闲状态的处理器，它会根据指定的时间间隔检查连接的读取空闲状态。它内部使用了 <code>ScheduledExecutorService</code> 来定期检查连接的读取状态。</p><p>ReadTimeoutHandler类当在指定时间内没有发生读事件时，抛出异常ReadTimeoutException。在 <code>run()</code> 方法中，首先计算下一个超时的延迟时间 <code>nextDelay</code>。如果当前不是正在读取状态（<code>reading</code> 为 false），则根据当前时间与上次读取时间的差值来调整 <code>nextDelay</code>，以保证超时的准确性。</p><p>接下来，通过判断 <code>nextDelay</code> 的值来确定读取是否已经超时。如果 <code>nextDelay</code> 小于等于 0，表示读取已经超时，需要执行相应的操作。首先，重新调度一个新的超时任务，并更新 <code>readerIdleTimeout</code> 变量。然后，根据 <code>firstReaderIdleEvent</code> 的值判断是否为第一次读取空闲事件。如果是第一次，则设置 <code>firstReaderIdleEvent</code> 为 false，否则表示已经发生过读取空闲事件。</p><p>接下来，尝试创建一个 <code>IdleStateEvent</code> 实例，表示读取空闲事件，并调用 <code>channelIdle()</code> 方法来通知相关的处理器。如果在这个过程中发生异常，将通过调用 <code>ctx.fireExceptionCaught(t)</code> 来传播异常。</p><p>如果 <code>nextDelay</code> 大于 0，表示读取还未超时，需要重新调度一个新的监测任务，使用 <code>nextDelay</code> 作为延迟时间，以便在接下来的时间内继续监测读取空闲状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nextDelay</span> <span class="hljs-operator">=</span> readerIdleTimeNanos;<br>    <span class="hljs-keyword">if</span> (!reading) &#123;<br>        <span class="hljs-comment">//计算是否idle的关键</span><br>        nextDelay -= ticksInNanos() - lastReadTime;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextDelay &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//空闲了</span><br>        <span class="hljs-comment">// Reader is idle - set a new timeout and notify the callback.</span><br>        readerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstReaderIdleEvent;<br>        <span class="hljs-comment">//firstReaderIdleEvent下个读来之前，第一次idle之后，可能触发多次，都属于非第一次idle.</span><br>        firstReaderIdleEvent = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> newIdleStateEvent(IdleState.READER_IDLE, first);<br>            channelIdle(ctx, event);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ctx.fireExceptionCaught(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//重新其一个监测task，用nextdelay时间</span><br>        <span class="hljs-comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span><br>        readerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写Idle检测原理和参数observeOutput用途"><a href="#写Idle检测原理和参数observeOutput用途" class="headerlink" title="写Idle检测原理和参数observeOutput用途"></a><strong>写Idle检测原理和参数observeOutput用途</strong></h3><blockquote><p>用“写”是否完成进行判断</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (timeoutNanos &gt; <span class="hljs-number">0</span>) &#123;<br>        promise = promise.unvoid();<br>        <span class="hljs-comment">//写的时候schedule一个task去检查是否完成了。</span><br>        scheduleTimeout(ctx, promise);<br>    &#125;<br>    ctx.write(msg, promise);<br>&#125;        <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Was not written yet so issue a write timeout</span><br>    <span class="hljs-comment">// The promise itself will be failed with a ClosedChannelException once the close() was issued</span><br>    <span class="hljs-comment">// 判断写是否完成</span><br>    <span class="hljs-keyword">if</span> (!promise.isDone()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeTimedOut(ctx);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ctx.fireExceptionCaught(t);<br>        &#125;<br>    &#125;<br>    removeWriteTimeoutTask(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="observeOutput用途"><a href="#observeOutput用途" class="headerlink" title="observeOutput用途"></a><strong>observeOutput用途</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasOutputChanged</span><span class="hljs-params">(ChannelHandlerContext ctx, <span class="hljs-type">boolean</span> first)</span> &#123;<br>       <span class="hljs-keyword">if</span> (observeOutput) &#123;<br>           <span class="hljs-comment">//正常情况下，false，即写空闲的判断中的写是指写成功，但是实际上，有可能遇到几种情况：</span><br>           <span class="hljs-comment">//（1）写了，但是缓存区满了，写不出去；（2）写了一个大“数据”，写确实在“动”，但是没有完成。</span><br>           <span class="hljs-comment">//所以这个参数，判断是否有“写的意图”，而不是判断“是否写成功”。</span><br>           <span class="hljs-keyword">if</span> (lastChangeCheckTimeStamp != lastWriteTime) &#123;<br>               lastChangeCheckTimeStamp = lastWriteTime;<br><br>               <span class="hljs-comment">// But this applies only if it&#x27;s the non-first call.</span><br>               <span class="hljs-keyword">if</span> (!first) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>           <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> channel.unsafe();<br>           <span class="hljs-type">ChannelOutboundBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> unsafe.outboundBuffer();<br><br>           <span class="hljs-keyword">if</span> (buf != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">messageHashCode</span> <span class="hljs-operator">=</span> System.identityHashCode(buf.current());<br>               <span class="hljs-type">long</span> <span class="hljs-variable">pendingWriteBytes</span> <span class="hljs-operator">=</span> buf.totalPendingWriteBytes();<br>               <span class="hljs-comment">//pendingWriteBytes 不等于上一次的pendingWriteBytes</span><br>               <span class="hljs-keyword">if</span> (messageHashCode != lastMessageHashCode || pendingWriteBytes != lastPendingWriteBytes) &#123;<br>                   lastMessageHashCode = messageHashCode;<br>                   lastPendingWriteBytes = pendingWriteBytes;<br><br>                   <span class="hljs-keyword">if</span> (!first) &#123;<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                   &#125;<br>               &#125;<br><br>               <span class="hljs-type">long</span> <span class="hljs-variable">flushProgress</span> <span class="hljs-operator">=</span> buf.currentProgress();<br>               <span class="hljs-comment">//写进度</span><br>               <span class="hljs-keyword">if</span> (flushProgress != lastFlushProgress) &#123;<br>                   lastFlushProgress = flushProgress;<br><br>                   <span class="hljs-keyword">if</span> (!first) &#123;<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
      <category>极客时间</category>
      
      <category>Netty源码剖析与实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>极客时间</tag>
      
      <tag>源码</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极客时间《netty源码剖析与实战》学习笔记2</title>
    <link href="/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <url>/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h2 id="7-Netty的锁"><a href="#7-Netty的锁" class="headerlink" title="7.Netty的锁"></a><strong>7.Netty的锁</strong></h2><h3 id="分析同步问题的三要素"><a href="#分析同步问题的三要素" class="headerlink" title="分析同步问题的三要素"></a><strong>分析同步问题的三要素</strong></h3><ul><li>原子性，线程切换带来原子性问题</li><li>可见性，缓存带来的可见性问题</li><li>有序性，编译优化产生有序性问题</li></ul><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a><strong>锁的分类</strong></h3><ul><li>对竞争的态度：乐观锁（java.util.concurrent 包中的原子类）、悲观锁（Synchronized）</li><li>对等待锁是否公平：公平锁 new ReentrantLock (true)、非公平锁 new ReentrantLock ()</li><li>是否可以共享：共享锁与独享锁：ReadWriteLock ，其读锁是共享锁，其写锁是独享</li></ul><h2 id="Netty中使用锁的五个关键点"><a href="#Netty中使用锁的五个关键点" class="headerlink" title="Netty中使用锁的五个关键点"></a><strong>Netty中使用锁的五个关键点</strong></h2><h3 id="注意锁的范围和-gt-减少粒度"><a href="#注意锁的范围和-gt-减少粒度" class="headerlink" title="注意锁的范围和-&gt;减少粒度"></a><strong>注意锁的范围和-&gt;减少粒度</strong></h3><p>初始化 channel （io.netty.bootstrap.ServerBootstrap#init） Synchronized method -&gt; Synchronized block 不是将整个方法加锁，而是在代码块上加锁。</p><p>对于option0和attrs0两个不会出现线程安全问题的代码不加锁。</p><p><img src="https://pic1.zhimg.com/80/v2-24033f5c31a99b059aed60d35260ce08_720w.webp" alt="img"></p><h3 id="注意锁对象本身的大小-gt-减少空间占用"><a href="#注意锁对象本身的大小-gt-减少空间占用" class="headerlink" title="注意锁对象本身的大小-&gt;减少空间占用"></a><strong>注意锁对象本身的大小-&gt;减少空间占用</strong></h3><p>统计待发送的字节数（io.netty.channel.ChannelOutboundBuffer AtomicLong -&gt; Volatile long + AtomicLongFieldUpdater</p><p><img src="https://pic1.zhimg.com/80/v2-ece282236aabb36fc72e58da1a537504_720w.webp" alt="img"></p><p>看似代码变复杂了，而且没用。但是从对象所占用的字节数方面来看：</p><p>Atomic long VS long：</p><p>前者是一个对象，包含对象头（object header）以用来保存 hashcode、lock 等信息，32 位系统占 用8字节；64 位系统占 16 字节，所以在 64 位系统情况下：</p><ul><li>volatile long &#x3D; 8 bytes</li><li>AtomicLong &#x3D; 8 bytes （volatile long）+ 16bytes （对象头）+ 8 bytes (引用，不一定是8字节，因为会存在指针压缩等优化) &#x3D; 32 bytes</li></ul><p>至少节约 24 字节!</p><blockquote><p>结论：Atomic* objects -&gt; Volatile primary type + Static Atomic*FieldUpdater</p></blockquote><h3 id="注意锁的速度-gt-提高并发性"><a href="#注意锁的速度-gt-提高并发性" class="headerlink" title="注意锁的速度-&gt;提高并发性"></a><strong>注意锁的速度-&gt;提高并发性</strong></h3><p>netty可以根据不同情况，选择不同的并发包实现。</p><p>当JDK &lt; 1.8时，使用ConcurrentHashMapV8（ConcurrentHashMap 在 JDK8 中的版本）jdk8的实现拷贝到了netty中（现在netty中没有了）。</p><p><img src="https://pic4.zhimg.com/80/v2-032a9d1466742df6f8fe5ce13087058b_720w.webp" alt="img"></p><h3 id="不同场景下选择不同的并发包-gt-因需而变"><a href="#不同场景下选择不同的并发包-gt-因需而变" class="headerlink" title="不同场景下选择不同的并发包-&gt;因需而变"></a><strong>不同场景下选择不同的并发包-&gt;因需而变</strong></h3><ol><li>关闭和等待关闭事件执行器（Event Execute）</li></ol><p>Object.wait&#x2F;notify -&gt; CountDownLatch</p><p>io.netty.util.concurrent.SingleThreadEventExecutor#threadLock：</p><p><img src="https://pic2.zhimg.com/80/v2-c806e34d4d7e9f8667b0fc60a9d6bb19_720w.webp" alt="img"></p><p><strong>Object.wait&#x2F;notify</strong> 需要把要执行的语句放到一个监视器中。</p><ol><li>Nio Event loop中负责存储task的<br>Queue Jdk’s LinkedBlockingQueue <strong>(MPMC多生产者多消费者模式</strong>) -&gt; jctools’ <strong>MPSC(多生产者单消费者模式)</strong> io.netty.util.internal.PlatformDependent.Mpsc#newMpscQueue(int)：</li></ol><p>对于Event loop来说，它只绑定了一个线程，所以只有一个消费者。</p><p>说明优化的基础是建立在具体的场景上的。</p><h3 id="衡量好锁的价值-gt-能不用则不用"><a href="#衡量好锁的价值-gt-能不用则不用" class="headerlink" title="衡量好锁的价值-&gt;能不用则不用"></a><strong>衡量好锁的价值-&gt;能不用则不用</strong></h3><ol><li>局部串行：netty对于每个连接而言，都是一个串行化操作。Channel 的 I&#x2F;O 请求处理 Pipeline 是串行的</li></ol><p><img src="https://pic2.zhimg.com/80/v2-aa171f49bd974476c51f632729e259a9_720w.webp" alt="img"></p><ol><li>整体并行：多个串行化的线程（NioEventLoop）</li></ol><p><img src="https://pic1.zhimg.com/80/v2-53dde61eb68bc34d7e595421281a3d0c_720w.webp" alt="img"></p><p>Netty 应用场景下：局部串行 + 整体并行 &gt; 一个队列 + 多个线程模式:</p><ul><li>降低用户开发难度、逻辑简单、提升处理性能</li><li>避免锁带来的上下文切换和并发保护等额外开销</li></ul><ol><li>避免用锁： 用 ThreadLocal 来避免资源争用，例如 Netty 轻量级的线程池实</li></ol><h2 id="8-Netty如何玩转内存使用"><a href="#8-Netty如何玩转内存使用" class="headerlink" title="8.Netty如何玩转内存使用"></a><strong>8.Netty如何玩转内存使用</strong></h2><p>内存使用的目标：</p><ul><li>内存占用少</li><li>应用速度快</li></ul><p>对于java而言:减少Full GC的STWW（Stop the world）时间</p><h3 id="减少对像本身大小"><a href="#减少对像本身大小" class="headerlink" title="减少对像本身大小"></a><strong>减少对像本身大小</strong></h3><ul><li>用基本类型就不要用包装类</li><li>应该定义成类变量的不要定义为实例变量</li></ul><h3 id="对分配内存进行预估"><a href="#对分配内存进行预估" class="headerlink" title="对分配内存进行预估"></a><strong>对分配内存进行预估</strong></h3><ul><li>对于已经可以预知固定 size 的 HashMap避免扩容 可以提前计算好初始size或者直接使用</li></ul><p>com.google.common.collect.Maps#newHashMapWithExpectedSize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; HashMap&lt;K, V&gt; <span class="hljs-title function_">newHashMapWithExpectedSize</span><span class="hljs-params">(<span class="hljs-type">int</span> expectedSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(capacity(expectedSize));<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">(<span class="hljs-type">int</span> expectedSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (expectedSize &lt; <span class="hljs-number">3</span>) &#123;<br>        CollectPreconditions.checkNonnegative(expectedSize, <span class="hljs-string">&quot;expectedSize&quot;</span>);<br>        <span class="hljs-keyword">return</span> expectedSize + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> expectedSize &lt; <span class="hljs-number">1073741824</span> ? (<span class="hljs-type">int</span>)((<span class="hljs-type">float</span>)expectedSize / <span class="hljs-number">0.75F</span> + <span class="hljs-number">1.0F</span>) : <span class="hljs-number">2147483647</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Netty 根据接受到的数据动态调整（guess）下个要分配的 Buffer 的大小。可参考 io.netty.channel.AdaptiveRecvByteBufAllocator</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 接受数据buffer的容量会尽可能的足够大以接受数据</span><br><span class="hljs-comment">         * 也尽可能的小以不会浪费它的空间</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> actualReadBytes</span><br><span class="hljs-comment">         */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">record</span><span class="hljs-params">(<span class="hljs-type">int</span> actualReadBytes)</span> &#123;<br>    <span class="hljs-comment">//尝试是否可以减小分配的空间仍然能满足需求：</span><br>    <span class="hljs-comment">//尝试方法：当前实际读取的size是否小于或等于打算缩小的尺寸</span><br>    <span class="hljs-keyword">if</span> (actualReadBytes &lt;= SIZE_TABLE[max(<span class="hljs-number">0</span>, index - INDEX_DECREMENT - <span class="hljs-number">1</span>)]) &#123;<br>        <span class="hljs-comment">//decreaseNow: 连续2次尝试减小都可以</span><br>        <span class="hljs-keyword">if</span> (decreaseNow) &#123;<br>            <span class="hljs-comment">//减小</span><br>            index = max(index - INDEX_DECREMENT, minIndex);<br>            nextReceiveBufferSize = SIZE_TABLE[index];<br>            decreaseNow = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            decreaseNow = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断是否实际读取的数据大于等于预估的，如果是，尝试扩容</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (actualReadBytes &gt;= nextReceiveBufferSize) &#123;<br>        index = min(index + INDEX_INCREMENT, maxIndex);<br>        nextReceiveBufferSize = SIZE_TABLE[index];<br>        decreaseNow = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Zero-Copy-零复制"><a href="#Zero-Copy-零复制" class="headerlink" title="Zero-Copy 零复制"></a><strong>Zero-Copy 零复制</strong></h3><p>使用逻辑组合，代替实际复制。 例如 CompositeByteBuf： io.netty.handler.codec.ByteToMessageDecoder#COMPOSITE_CUMULATOR 避免了内存的复制而将数据组合到一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Cumulator</span> <span class="hljs-variable">COMPOSITE_CUMULATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cumulator</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">cumulate</span><span class="hljs-params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> &#123;<br>        ByteBuf buffer;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (cumulation.refCnt() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the</span><br>                <span class="hljs-comment">// user use slice().retain() or duplicate().retain().</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See:</span><br>                <span class="hljs-comment">// - https://github.com/netty/netty/issues/2327</span><br>                <span class="hljs-comment">// - https://github.com/netty/netty/issues/1764</span><br>                buffer = expandCumulation(alloc, cumulation, in.readableBytes());<br>                buffer.writeBytes(in);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                CompositeByteBuf composite;<br><br>                <span class="hljs-comment">//创建composite bytebuf，如果已经创建过，就不用了</span><br>                <span class="hljs-keyword">if</span> (cumulation <span class="hljs-keyword">instanceof</span> CompositeByteBuf) &#123;<br>                    composite = (CompositeByteBuf) cumulation;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    composite = alloc.compositeBuffer(Integer.MAX_VALUE);<br>                    composite.addComponent(<span class="hljs-literal">true</span>, cumulation);<br>                &#125;<br>                <span class="hljs-comment">//避免内存复制</span><br>                composite.addComponent(<span class="hljs-literal">true</span>, in);<br>                in = <span class="hljs-literal">null</span>;<br>                buffer = composite;<br>            &#125;<br>            <span class="hljs-keyword">return</span> buffer;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (in != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// We must release if the ownership was not transferred as otherwise it may produce a leak if</span><br>                <span class="hljs-comment">// writeBytes(...) throw for whatever release (for example because of OutOfMemoryError).</span><br>                in.release();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>使用包装，代替实际复制。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = data.getBytes();  <br><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(bytes)<br></code></pre></td></tr></table></figure><ul><li>调用 JDK 的 Zero-Copy 接口。 Netty 中也通过在 DefaultFileRegion 中包装了 NIO 的 FileChannel.transferTo() 方法实 现了零拷贝：io.netty.channel.DefaultFileRegion#transferTo</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(WritableByteChannel target, <span class="hljs-type">long</span> position)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count - position;<br>    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span> || position &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                <span class="hljs-string">&quot;position out of range: &quot;</span> + position +<br>                <span class="hljs-string">&quot; (expected: 0 - &quot;</span> + (<span class="hljs-built_in">this</span>.count - <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;)&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (refCnt() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalReferenceCountException</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// Call open to make sure fc is initialized. This is a no-oop if we called it before.</span><br>    open();<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">written</span> <span class="hljs-operator">=</span> file.transferTo(<span class="hljs-built_in">this</span>.position + position, count, target);<br>    <span class="hljs-keyword">if</span> (written &gt; <span class="hljs-number">0</span>) &#123;<br>        transferred += written;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (written == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// If the amount of written data is 0 we need to check if the requested count is bigger then the</span><br>        <span class="hljs-comment">// actual file itself as it may have been truncated on disk.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/8868</span><br>        validate(<span class="hljs-built_in">this</span>, position);<br>    &#125;<br>    <span class="hljs-keyword">return</span> written;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a><strong>堆外内存</strong></h3><p>堆外内存生活场景：</p><ul><li><p>夏日，小区周边的烧烤店铺，人满为患坐不下，店家常常怎么办？</p></li><li><p>解决思路：店铺门口摆很多桌子招待客人。</p></li><li><ul><li>店内 -&gt; JVM 内部 -&gt; 堆（heap) + 非堆（non heap）</li><li>店外 -&gt; JVM 外部 -&gt; 堆外（off heap）</li></ul></li></ul><p>优点：</p><ul><li>更广阔的“空间 ”，缓解店铺内压力 -&gt; 破除堆空间限制，减轻 GC 压力</li><li>减少“冗余”细节（假设烧烤过程为了气氛在室外进行：烤好直接上桌：vs 烤好还 要进店内）-&gt; 避免复制</li></ul><p>缺点：</p><ul><li>需要搬桌子 -&gt; 创建速度稍慢</li><li>受城管管、风险大 -&gt; 堆外内存受操作系统管理</li></ul><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a><strong>内存池</strong></h3><p><strong>点菜单的演进：</strong></p><p>• 一张纸：一桌客人一张纸</p><p>• 点菜平板：循环使用</p><p><strong>为什么引入对象池：</strong></p><p>• 创建对象开销大</p><p>• 对象高频率创建且可复用</p><p>• 支持并发又能保护系统</p><p>• 维护、共享有限的资源</p><p><strong>如何实现对象池？</strong></p><p>• 开源实现：Apache Commons Pool （全局共享，资源争用比较厉害）</p><p>• Netty 轻量级对象池实现 io.netty.util.Recycler （基于netty场景实现）</p><h2 id="源码解读Netty内存使用"><a href="#源码解读Netty内存使用" class="headerlink" title="源码解读Netty内存使用"></a><strong>源码解读Netty内存使用</strong></h2><h3 id="内存池-x2F-非内存池的默认选择及切换方式？"><a href="#内存池-x2F-非内存池的默认选择及切换方式？" class="headerlink" title="内存池&#x2F;非内存池的默认选择及切换方式？"></a><strong>内存池&#x2F;非内存池的默认选择及切换方式？</strong></h3><p>以io.netty.allocator.type为准，没有的话，安卓平台用非池化实现，其他用池化实现</p><p><strong>默认使用池化的实现</strong>，可以使用io.netty.allocator.type设置池化或者非池化的实现。 io.netty.channel.DefaultChannelConfig#allocator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认bytebuf分配器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ByteBufAllocator</span> <span class="hljs-variable">allocator</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT;<br></code></pre></td></tr></table></figure><p>io.netty.buffer.ByteBufAllocator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBufAllocator</span> <span class="hljs-variable">DEFAULT</span> <span class="hljs-operator">=</span> ByteBufUtil.DEFAULT_ALLOCATOR;<br></code></pre></td></tr></table></figure><p>io.netty.buffer.ByteBufUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ByteBufAllocator DEFAULT_ALLOCATOR;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//以io.netty.allocator.type为判断标准，没有的话，安卓平台用非池化实现，其他用池化实现。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">allocType</span> <span class="hljs-operator">=</span> SystemPropertyUtil.get(<br>                <span class="hljs-string">&quot;io.netty.allocator.type&quot;</span>, PlatformDependent.isAndroid() ? <span class="hljs-string">&quot;unpooled&quot;</span> : <span class="hljs-string">&quot;pooled&quot;</span>);<br>        allocType = allocType.toLowerCase(Locale.US).trim();<br>        ByteBufAllocator alloc;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;unpooled&quot;</span>.equals(allocType)) &#123;<br>            alloc = UnpooledByteBufAllocator.DEFAULT;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;</span>, allocType);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;pooled&quot;</span>.equals(allocType)) &#123;<br>            alloc = PooledByteBufAllocator.DEFAULT;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;</span>, allocType);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//io.netty.allocator.type设置的不是&quot;unpooled&quot;或者&quot;pooled&quot;，就用池化实现。</span><br>            alloc = PooledByteBufAllocator.DEFAULT;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.allocator.type: pooled (unknown: &#123;&#125;)&quot;</span>, allocType);<br>        &#125;<br>        DEFAULT_ALLOCATOR = alloc;<br>        THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.threadLocalDirectBufferSize&quot;</span>, <span class="hljs-number">0</span>);<br>        logger.debug(<span class="hljs-string">&quot;-Dio.netty.threadLocalDirectBufferSize: &#123;&#125;&quot;</span>, THREAD_LOCAL_BUFFER_SIZE);<br>        MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.maxThreadLocalCharBufferSize&quot;</span>, <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>);<br>        logger.debug(<span class="hljs-string">&quot;-Dio.netty.maxThreadLocalCharBufferSize: &#123;&#125;&quot;</span>, MAX_CHAR_BUFFER_SIZE);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="两种设置池化实现的方式"><a href="#两种设置池化实现的方式" class="headerlink" title="两种设置池化实现的方式"></a><strong>两种设置池化实现的方式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">.childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)<br> <span class="hljs-type">String</span> <span class="hljs-variable">allocType</span> <span class="hljs-operator">=</span> SystemPropertyUtil.get(<br>                <span class="hljs-string">&quot;io.netty.allocator.type&quot;</span>, PlatformDependent.isAndroid() ? <span class="hljs-string">&quot;unpooled&quot;</span> : <span class="hljs-string">&quot;pooled&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="堆外内存的分配本质？内存池实现"><a href="#堆外内存的分配本质？内存池实现" class="headerlink" title="堆外内存的分配本质？内存池实现?"></a><strong>堆外内存的分配本质？内存池实现?</strong></h3><p>io.netty.buffer.PooledDirectByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <br>    <span class="hljs-comment">//Recycler就是Netty的轻量级内存池的实现</span><br>    Recycler&lt;PooledDirectByteBuf&gt; RECYCLER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Recycler</span>&lt;PooledDirectByteBuf&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> PooledDirectByteBuf <span class="hljs-title function_">newObject</span><span class="hljs-params">(Handle&lt;PooledDirectByteBuf&gt; handle)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledDirectByteBuf</span>(handle, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//从“池”里借一个用</span><br>    <span class="hljs-keyword">static</span> PooledDirectByteBuf <span class="hljs-title function_">newInstance</span><span class="hljs-params">(<span class="hljs-type">int</span> maxCapacity)</span> &#123;<br>        <span class="hljs-type">PooledDirectByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> RECYCLER.get();<br>        buf.reuse(maxCapacity);<br>        <span class="hljs-keyword">return</span> buf;<br>    &#125;<br></code></pre></td></tr></table></figure><p>io.netty.util.Recycler 从池中取对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxCapacityPerThread == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//表明没有开启池化</span><br>        <span class="hljs-keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);<br>    &#125;<br>    Stack&lt;T&gt; stack = threadLocal.get();<br>    DefaultHandle&lt;T&gt; handle = stack.pop();<br>    <span class="hljs-comment">//试图从“池”中取出一个，没有就新建一个</span><br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">null</span>) &#123;<br>        handle = stack.newHandle();<br>        handle.value = newObject(handle);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) handle.value;<br>&#125;<br></code></pre></td></tr></table></figure><p>io.netty.buffer.PooledByteBuf 还对象到池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//归还对象到“池”里去，pipeline的tail会调用</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deallocate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (handle &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.handle;<br>        <span class="hljs-built_in">this</span>.handle = -<span class="hljs-number">1</span>;<br>        memory = <span class="hljs-literal">null</span>;<br>        chunk.arena.free(chunk, tmpNioBuf, handle, maxLength, cache);<br>        tmpNioBuf = <span class="hljs-literal">null</span>;<br>        chunk = <span class="hljs-literal">null</span>;<br>        recycle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>io.netty.util.Recycler的default实现，具体写明如何还回到内存池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultHandle</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handle</span>&lt;T&gt; &#123;<br>    ......<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recycle</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-keyword">if</span> (object != value) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;object does not belong to handle&quot;</span>);<br>        &#125;<br><br>        Stack&lt;?&gt; stack = <span class="hljs-built_in">this</span>.stack;<br>        <span class="hljs-keyword">if</span> (lastRecycledId != recycleId || stack == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;recycled already&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//释放用完的对象到池里面去</span><br>        stack.push(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="怎么从堆外内存切换堆内使用？"><a href="#怎么从堆外内存切换堆内使用？" class="headerlink" title="怎么从堆外内存切换堆内使用？"></a><strong>怎么从堆外内存切换堆内使用？</strong></h3><p>io.netty.util.internal.PlatformDependent</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">// We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.<br>//使用堆外内存两个条件：1 有cleaner方法去释放堆外内存； 2 io.netty.noPreferDirect 不能设置为true<br>DIRECT_BUFFER_PREFERRED = CLEANER != NOOP<br>    &amp;&amp; !SystemPropertyUtil.getBoolean(&quot;io.netty.noPreferDirect&quot;, false);<br>if (logger.isDebugEnabled()) &#123;<br>    logger.debug(&quot;-Dio.netty.noPreferDirect: &#123;&#125;&quot;, !DIRECT_BUFFER_PREFERRED);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法 1：参数设置 io.netty.noPreferDirect &#x3D; true;</li><li>方法 2：传入构造参数false<br>ServerBootstrap serverBootStrap &#x3D; new ServerBootstrap();<br>UnpooledByteBufAllocator unpooledByteBufAllocator &#x3D; new UnpooledByteBufAllocator(false); &#x2F;&#x2F;不推荐<br>serverBootStrap.childOption(ChannelOption.ALLOCATOR, unpooledByteBufAllocator)</li></ul><h3 id="堆外内存的分配本质？"><a href="#堆外内存的分配本质？" class="headerlink" title="堆外内存的分配本质？"></a><strong>堆外内存的分配本质？</strong></h3><p>首先在io.netty.buffer.UnpooledByteBufAllocator会先进行判断，是否有hasUnsafe()方法和是否有noCleaner()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ByteBuf <span class="hljs-title function_">newDirectBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">int</span> maxCapacity)</span> &#123;<br>       <span class="hljs-keyword">final</span> ByteBuf buf;<br>       <span class="hljs-keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;<br>           buf = noCleaner ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</span>(<span class="hljs-built_in">this</span>, initialCapacity, maxCapacity) :<br>                   <span class="hljs-comment">//大多情况：</span><br>                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstrumentedUnpooledUnsafeDirectByteBuf</span>(<span class="hljs-built_in">this</span>, initialCapacity, maxCapacity);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstrumentedUnpooledDirectByteBuf</span>(<span class="hljs-built_in">this</span>, initialCapacity, maxCapacity);<br>       &#125;<br>       <span class="hljs-keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);<br>   &#125;<br></code></pre></td></tr></table></figure><p>io.netty.buffer.UnpooledDirectByteBuf#allocateDirect，最终实际调用的是JDK的方法</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
      <category>极客时间</category>
      
      <category>Netty源码剖析与实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>极客时间</tag>
      
      <tag>源码</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty入门</title>
    <link href="/2023/06/21/netty%E5%85%A5%E9%97%A8/"/>
    <url>/2023/06/21/netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1、简述"><a href="#1、简述" class="headerlink" title="1、简述"></a>1、简述</h2><p>netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端</p><p><a href="https://netty.io/"> netty.io</a></p><h2 id="2、为什么使用netty"><a href="#2、为什么使用netty" class="headerlink" title="2、为什么使用netty"></a>2、为什么使用netty</h2><h3 id="NIO缺点"><a href="#NIO缺点" class="headerlink" title="NIO缺点"></a>NIO缺点</h3><ul><li>api繁杂，</li><li>需要熟悉java多线程，网络编程</li><li>epoll bug会导致selector空轮询，最终导致cpu 100%</li></ul><h3 id="netty优点"><a href="#netty优点" class="headerlink" title="netty优点"></a>netty优点</h3><ul><li>api简单</li><li>支持多种协议</li><li>性能高</li><li>社区活跃</li></ul><h2 id="3、架构"><a href="#3、架构" class="headerlink" title="3、架构"></a>3、架构</h2><p><img src="/img/netty%E5%85%A5%E9%97%A8/img-20230306195432035.png" alt="image-20230306195432035"></p><ol><li><strong>绿色 core</strong>：零拷贝、api库、可扩展事件模型</li><li><strong>黄色 protocol Support协议</strong> 包括http、websocket ssl等等</li><li><strong>红色 传输服务</strong> socket http tunnel等等</li></ol><h2 id="4、hello-word"><a href="#4、hello-word" class="headerlink" title="4、hello word"></a>4、hello word</h2><img src="https://pic4.zhimg.com/80/v2-7eefba893a65706eb6bbe4115cbd0b83_720w.webp" alt="img" style="zoom: 80%;" /><p>根据上面图上的模型进行编写hello word，</p><h3 id="4-1-创建服务端启动类"><a href="#4-1-创建服务端启动类" class="headerlink" title="4.1 创建服务端启动类"></a>4.1 创建服务端启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建两个线程组 boosGroup、workerGroup</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建服务端的启动对象，设置参数</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            <span class="hljs-comment">//设置两个线程组boosGroup和workerGroup</span><br>            bootstrap.group(bossGroup, workerGroup)<br>                <span class="hljs-comment">//设置服务端通道实现类型    </span><br>                .channel(NioServerSocketChannel.class)<br>                <span class="hljs-comment">//设置线程队列得到连接个数    </span><br>                .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                <span class="hljs-comment">//设置保持活动连接状态    </span><br>                .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//使用匿名内部类的形式初始化通道对象    </span><br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">//给pipeline管道设置处理器</span><br>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServerHandler</span>());<br>                        &#125;<br>                    &#125;);<span class="hljs-comment">//给workerGroup的EventLoop对应的管道设置处理器</span><br>            System.out.println(<span class="hljs-string">&quot;java技术爱好者的服务端已经准备就绪...&quot;</span>);<br>            <span class="hljs-comment">//绑定端口号，启动服务端</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(<span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">//对关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-创建服务端处理器"><a href="#4-2-创建服务端处理器" class="headerlink" title="4.2 创建服务端处理器"></a>4.2 创建服务端处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的Handler需要继承Netty规定好的HandlerAdapter</span><br><span class="hljs-comment"> * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取客户端发送过来的消息</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;收到客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;发送的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//发送消息给客户端</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;服务端已收到消息，并给你发送一个问号?&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//发生异常，关闭通道</span><br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3创建客户端启动类"><a href="#4-3创建客户端启动类" class="headerlink" title="4.3创建客户端启动类"></a>4.3创建客户端启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">eventExecutors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建bootstrap对象，配置参数</span><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            <span class="hljs-comment">//设置线程组</span><br>            bootstrap.group(eventExecutors)<br>                <span class="hljs-comment">//设置客户端的通道实现类型    </span><br>                .channel(NioSocketChannel.class)<br>                <span class="hljs-comment">//使用匿名内部类初始化通道</span><br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">//添加客户端通道的处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;客户端准备就绪，随时可以起飞~&quot;</span>);<br>            <span class="hljs-comment">//连接服务端</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">//对通道关闭进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭线程组</span><br>            eventExecutors.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4创建客户端处理器"><a href="#4-4创建客户端处理器" class="headerlink" title="4.4创建客户端处理器"></a>4.4创建客户端处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//发送消息到服务端</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//接收服务端发送过来的消息</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;收到服务端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5测试"><a href="#4-5测试" class="headerlink" title="4.5测试"></a>4.5测试</h3><p>先运行server再运行client</p><p>MyServer打印结果:</p><p><img src="https://pic1.zhimg.com/80/v2-aa144d6ad2688f69b0f5ef7dc916a3f4_720w.webp" alt="img"></p><p>MyClient打印结果：</p><p><img src="https://pic4.zhimg.com/80/v2-e6bc4dec6eecb3ae30f55c7a6487e1f7_720w.webp" alt="img"></p><h2 id="5、netty的特性和重要组件"><a href="#5、netty的特性和重要组件" class="headerlink" title="5、netty的特性和重要组件"></a>5、netty的特性和重要组件</h2><h3 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h3><p>如果handler出来又一些长时间的业务处理，那么可以交给taskQueue异步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取到线程池eventLoop，添加线程，执行</span><br>        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span><br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-schedduleTaskQueue延时任务队列"><a href="#5-2-schedduleTaskQueue延时任务队列" class="headerlink" title="5.2 schedduleTaskQueue延时任务队列"></a>5.2 schedduleTaskQueue延时任务队列</h3><p>和任务队列相似，不同的是可以延迟一定时间再执行设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;,<span class="hljs-number">5</span>, TimeUnit.SECONDS);<span class="hljs-comment">//5秒后执行</span><br></code></pre></td></tr></table></figure><h3 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h3><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666);<br></code></pre></td></tr></table></figure><p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p><p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p><h3 id="5-4-BootStrap-和ServerBootStrap"><a href="#5-4-BootStrap-和ServerBootStrap" class="headerlink" title="5.4 BootStrap 和ServerBootStrap"></a>5.4 BootStrap 和ServerBootStrap</h3><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p><p><img src="https://pic1.zhimg.com/80/v2-dab6b780993979fcb86ef14553c16720_720w.webp" alt="img"></p><p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p><p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p><p><img src="https://pic4.zhimg.com/80/v2-dd3a866c356ee7bd24d23319d08116ef_720w.webp" alt="img"></p><h4 id="1）-group"><a href="#1）-group" class="headerlink" title="1） group()"></a>1） group()</h4><p>服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并且把连接注册到workerGroup的Selector中。</li><li>workerGroup 处理每一个连接发生的读写时间。</li></ul><p><strong>线程组中线程数是多少？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用一个常量保存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DEFAULT_EVENT_LOOP_THREADS;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量</span><br>        DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<br>                <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));<br><br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor, Object... args)</span> &#123;<br>        <span class="hljs-comment">//如果不传入，则使用常量的值，也就是cpu核数的两倍</span><br>        <span class="hljs-built_in">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="2）channel"><a href="#2）channel" class="headerlink" title="2）channel()"></a>2）channel()</h4><p>通道类型有：</p><p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。</p><p><strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p></blockquote><p><strong>OioSocketChannel：</strong> 同步阻塞的客户端 TCP Socket 连接。</p><p><strong>OioServerSocketChannel：</strong> 同步阻塞的服务器端 TCP Socket 连接。</p><p><strong>NioSctpChannel：</strong> 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。</p><p><strong>NioSctpServerChannel</strong>： 异步的 Sctp 服务器端连接。</p><h4 id="3）option-childOption"><a href="#3）option-childOption" class="headerlink" title="3）option() childOption()"></a>3）option() childOption()</h4><ul><li>option设置的是服务端用于接收进来的连接，也就是bossGroup</li><li>childOption是提供给父管道接收的连接，workerGroup</li></ul><p>SocketChannel参数，也就是childOption()常用的参数：</p><blockquote><p><strong>SO_RCVBUF</strong> Socket参数，TCP数据接收缓冲区大小。<br><strong>TCP_NODELAY</strong> TCP参数，立即发送数据，默认值为Ture。<br><strong>SO_KEEPALIVE</strong> Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p></blockquote><p>ServerSocketChannel参数，也就是option()常用参数：</p><blockquote><p><strong>SO_BACKLOG</strong> Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p></blockquote><h4 id="4）设置流水线（重点）"><a href="#4）设置流水线（重点）" class="headerlink" title="4）设置流水线（重点）"></a>4）设置流水线（重点）</h4><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p><p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用匿名内部类的形式初始化通道对象</span><br>bootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//给pipeline管道设置自定义的处理器</span><br>        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServerHandler</span>());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>处理器Handler主要分为两种：</p><blockquote><p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p></blockquote><p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p><p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p><p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p><ol><li>注册事件 fireChannelRegistered。</li><li>连接建立事件 fireChannelActive。</li><li>读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</li><li>异常通知事件 fireExceptionCaught。</li><li>用户自定义事件 fireUserEventTriggered。</li><li>Channel 可写状态变化事件 fireChannelWritabilityChanged。</li><li>连接关闭事件 fireChannelInactive。</li></ol><p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p><ol><li>端口绑定 bind。</li><li>连接服务端 connect。</li><li>写事件 write。</li><li>刷新时间 flush。</li><li>读事件 read。</li><li>主动断开连接 disconnect。</li><li>关闭 channel 事件 close。</li></ol><h4 id="5）-bind"><a href="#5）-bind" class="headerlink" title="5） bind()"></a>5） bind()</h4><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步</p><h3 id="5、-channel"><a href="#5、-channel" class="headerlink" title="5、 channel"></a>5、 channel</h3><p>channel为用户提供：</p><ol><li>通道当前的状态（例如它是打开？还是已连接？）</li><li>channel的配置参数（例如接收缓冲区的大小）</li><li>channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</li></ol><h4 id="1）获取状态"><a href="#1）获取状态" class="headerlink" title="1）获取状态"></a>1）获取状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isOpen</span><span class="hljs-params">()</span>; <span class="hljs-comment">//如果通道打开，则返回true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isRegistered</span><span class="hljs-params">()</span>;<span class="hljs-comment">//如果通道注册到EventLoop，则返回true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isActive</span><span class="hljs-params">()</span>;<span class="hljs-comment">//如果通道处于活动状态并且已连接，则返回true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isWritable</span><span class="hljs-params">()</span>;<span class="hljs-comment">//当且仅当I/O线程将立即执行请求的写入操作时，返回true。</span><br></code></pre></td></tr></table></figure><h4 id="2）获取配置"><a href="#2）获取配置" class="headerlink" title="2）获取配置"></a>2）获取配置</h4><p>获取单条配置信息，使用getOption()，代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> channel.config();<span class="hljs-comment">//获取配置参数</span><br><span class="hljs-comment">//获取ChannelOption.SO_BACKLOG参数,</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">soBackLogConfig</span> <span class="hljs-operator">=</span> config.getOption(ChannelOption.SO_BACKLOG);<br><span class="hljs-comment">//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128</span><br></code></pre></td></tr></table></figure><p>获取多条配置信息，使用getOptions()，代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> channel.config();<br>Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot; : &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）io操作"><a href="#3）io操作" class="headerlink" title="3）io操作"></a>3）io操作</h4><p>写操作 服务端到客户端</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ctx.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;这波啊，这波是肉蛋葱鸡~&quot;, CharsetUtil.UTF_8));<br></code></pre></td></tr></table></figure><p>连接</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ChannelFuture connect = channelFuture.channel().connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));//一般使用启动器，这种方式不常用<br></code></pre></td></tr></table></figure><p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">//获取ChannelPipeline对象<br>ChannelPipeline pipeline = ctx.channel().pipeline();<br>//往pipeline中添加ChannelHandler处理器，装配流水线<br>pipeline.addLast(new MyServerHandler());<br></code></pre></td></tr></table></figure><h3 id="6、Selector"><a href="#6、Selector" class="headerlink" title="6、Selector"></a>6、Selector</h3><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw">《NIO入门》</a>中，我已经讲过Selector了。</p><p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p><h3 id="7、PiPeline与ChannelPipeline"><a href="#7、PiPeline与ChannelPipeline" class="headerlink" title="7、PiPeline与ChannelPipeline"></a>7、PiPeline与ChannelPipeline</h3><p>我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p><p><img src="/img/netty%E5%85%A5%E9%97%A8/img-20230307193519223.png" alt="image-20230307193519223"></p><p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。</p><p><img src="/img/netty%E5%85%A5%E9%97%A8/img-20230307193528870.png" alt="image-20230307193528870"></p><p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p><h3 id="8、ChannelHandlerContext"><a href="#8、ChannelHandlerContext" class="headerlink" title="8、ChannelHandlerContext"></a>8、ChannelHandlerContext</h3><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p><p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。</p><p><img src="/img/netty%E5%85%A5%E9%97%A8/img-20230307193637688.png" alt="image-20230307193637688"></p><p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p><p><img src="/img/netty%E5%85%A5%E9%97%A8/img-20230307193702314.png" alt="image-20230307193702314"></p><h3 id="9、EventLoopGroup"><a href="#9、EventLoopGroup" class="headerlink" title="9、EventLoopGroup"></a>9、EventLoopGroup</h3><p><img src="/img/netty%E5%85%A5%E9%97%A8/img-20230307193734269.png" alt="image-20230307193734269"></p><p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p><p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p><p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p><h4 id="1）轮询机制实现原理"><a href="#1）轮询机制实现原理" class="headerlink" title="1）轮询机制实现原理"></a>1）轮询机制实现原理</h4><p>如果线程数是2的n次方，则采用这种算法。通过算发实现轮询。</p><p>index++ 对数组长度取模</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">private final AtomicInteger idx = new AtomicInteger();<br>private final EventExecutor[] executors;<br><br>@Override<br>public EventExecutor next() &#123;<br>    //idx.getAndIncrement()相当于idx++，然后对任务长度取模<br>    return executors[idx.getAndIncrement() &amp; executors.length - 1];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
