

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="HuanKang Zeng">
  <meta name="keywords" content="">
  
    <meta name="description" content="1 如何切换io模式在io.netty.example.echo.EchoServer类中，找到   OioEventLoopGroup()，将bossGroup和workerGroup的示例切换成其他IO，例如 new OioEventLoopGroup() ，以切换不同的开发模式。&#x2F;&#x2F; 更改这两行，换成想要的IOEventLoopGroup bossGroup &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="极客时间《netty源码剖析与实战》学习笔记2">
<meta property="og:url" content="http://muxiang123.github.io/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/index.html">
<meta property="og:site_name" content="MuXiang Blog">
<meta property="og:description" content="1 如何切换io模式在io.netty.example.echo.EchoServer类中，找到   OioEventLoopGroup()，将bossGroup和workerGroup的示例切换成其他IO，例如 new OioEventLoopGroup() ，以切换不同的开发模式。&#x2F;&#x2F; 更改这两行，换成想要的IOEventLoopGroup bossGroup &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-3dae64aaab1be8932dfe700454d3c2ad_720w.webp">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ef8a3ad3cbf910f9122e7d2f1f6d92b3_720w.webp">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-ab48ac6df1a8501308ced5d8bba7b584_720w.webp">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-c39e67cb5cacca1a83abf6078d83f6c7_720w.webp">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-f3205341049f20fd126117b211978c34_720w.webp">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-479693a68f46a13d73c5e4b38d5a9cb9_720w.webp">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-a4f714b10dc66042cbe05597c1d01762_720w.webp">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-b92ac3390dba142dd5c07e496378f8dc_720w.webp">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-184414c85fcbae94d5084c30f6d676d9_720w.webp">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-af2d850c62d844f90c87ab40c4f088f5_720w.webp">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-11d4193a99916879a4bb46aa7de1ef78_720w.webp">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-92af5693be90621266c531186492a22b_720w.webp">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-1576feaecc2bfe3cadb44432d0d3c639_720w.webp">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-478dfdbf49fb7236f1eed3c3e8c4034f_720w.webp">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-bdaf9058a99f6b15f44152b9d08d8002_720w.webp">
<meta property="article:published_time" content="2023-06-21T13:03:58.000Z">
<meta property="article:modified_time" content="2023-07-04T02:18:10.448Z">
<meta property="article:author" content="HuanKang Zeng">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="极客时间">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-3dae64aaab1be8932dfe700454d3c2ad_720w.webp">
  
  
  
  <title>极客时间《netty源码剖析与实战》学习笔记2 - MuXiang Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"muxiang123.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>MuXiang Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="极客时间《netty源码剖析与实战》学习笔记2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-21 21:03" pubdate>
          2023年6月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          28k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          233 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">极客时间《netty源码剖析与实战》学习笔记2</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="1-如何切换io模式"><a href="#1-如何切换io模式" class="headerlink" title="1 如何切换io模式"></a><strong>1 如何切换io模式</strong></h2><p>在io.netty.example.echo.EchoServer类中，找到</p>
<p><img src="https://pic2.zhimg.com/80/v2-3dae64aaab1be8932dfe700454d3c2ad_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol>
<li>OioEventLoopGroup()，将bossGroup和workerGroup的示例切换成其他IO，例如 <code>new OioEventLoopGroup()</code> ，以切换不同的开发模式。<br>&#x2F;&#x2F; 更改这两行，换成想要的IO<br>EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();<br>EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</li>
<li>在ServerBootstrap中切换channel。切换不同的IO模式</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">ServerBootstrap b = new ServerBootstrap();<br>b.group(bossGroup, workerGroup)<br> .channel(NioServerSocketChannel.class)<br></code></pre></td></tr></table></figure>

<p>三行解决切换。</p>
<h3 id="channel方法源码解析"><a href="#channel方法源码解析" class="headerlink" title="channel方法源码解析"></a><strong>channel方法源码解析</strong></h3><p>在channel方法中，是一个反射工厂的实现</p>
<p><img src="https://pic4.zhimg.com/80/v2-ef8a3ad3cbf910f9122e7d2f1f6d92b3_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>下图为ReflectiveChannelFactory的具体实现，这个类实现了ChannelFactory<T>。</p>
<p>在构造方法中的实参是一个泛型，我们将一个NioServerSocketChannel.class传入，则会获取这个类的无参构造器，然后再newChannel()方法中通过反射创建不同的channel类型。实现IO模式的切换。<strong>泛型+反射+工厂模式实现IO切换</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-ab48ac6df1a8501308ced5d8bba7b584_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="不需要切换客户端对应的Nio"><a href="#不需要切换客户端对应的Nio" class="headerlink" title="不需要切换客户端对应的Nio"></a><strong>不需要切换客户端对应的Nio</strong></h3><p>在服务器开发中，并不需要切换客户端对应的NioSocketChannel.</p>
<p>在doReadMessage方法中，实现了accept方法，通过accept方法创建出一个socketChannel。</p>
<p><img src="https://pic4.zhimg.com/80/v2-c39e67cb5cacca1a83abf6078d83f6c7_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f3205341049f20fd126117b211978c34_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="NioEventLoop是什么？"><a href="#NioEventLoop是什么？" class="headerlink" title="NioEventLoop是什么？"></a><strong>NioEventLoop是什么？</strong></h3><p>NioEventLoop继承SingleThreadEventLoop。将Channel注册到Selector，实现事件循环多路复用。在run方法中，写一个死循环实现selector，负责监听、处理事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//死循环监听、处理事件</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                    <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    select(wakenUp.getAndSet(<span class="hljs-literal">false</span>));<br>                    <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>                        selector.wakeup();<br>                    &#125;<br>                    <span class="hljs-comment">// fall through</span><br>                <span class="hljs-keyword">default</span>:<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-comment">// If we receive an IOException here its because the Selector is messed up. Let&#x27;s rebuild</span><br>                <span class="hljs-comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span><br>                rebuildSelector0();<br>                handleLoopException(e);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            cancelledKeys = <span class="hljs-number">0</span>;<br>            needsToSelectAgain = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ioRatio</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.ioRatio;<br>            <span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    runAllTasks();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioStartTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioTime</span> <span class="hljs-operator">=</span> System.nanoTime() - ioStartTime;<br>                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>        <span class="hljs-comment">// Always handle shutdown even if the loop processing threw an exception.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (isShuttingDown()) &#123;<br>                closeAll();<br>                <span class="hljs-keyword">if</span> (confirmShutdown()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-Netty如何支持三种Reactor"><a href="#2-Netty如何支持三种Reactor" class="headerlink" title="2.Netty如何支持三种Reactor"></a><strong>2.Netty如何支持三种Reactor</strong></h2><p>在NIO模式下，所对应的开发模式就是reactor。</p>
<h3 id="三种reactor"><a href="#三种reactor" class="headerlink" title="三种reactor"></a><strong>三种reactor</strong></h3><ol>
<li>单线程，一个线程去处理全部事件，容易阻塞。线程挂了系统也挂了。</li>
</ol>
<p><img src="https://pic2.zhimg.com/80/v2-479693a68f46a13d73c5e4b38d5a9cb9_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>\2. 多线程，将decode compute encode放入线程池进行处理。</p>
<p><img src="https://pic3.zhimg.com/80/v2-a4f714b10dc66042cbe05597c1d01762_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>\3. 主从多线程模式，在服务器开发中，acceptor专门放到一个reactor中。</p>
<p><img src="https://pic1.zhimg.com/80/v2-b92ac3390dba142dd5c07e496378f8dc_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="reactor核心流程"><a href="#reactor核心流程" class="headerlink" title="reactor核心流程"></a><strong>reactor核心流程</strong></h3><p>注册事件-&gt;扫描是否有事件发生-&gt;事件发生后进行处理</p>
<p><img src="https://pic2.zhimg.com/80/v2-184414c85fcbae94d5084c30f6d676d9_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="不同的reactor如何去实现"><a href="#不同的reactor如何去实现" class="headerlink" title="不同的reactor如何去实现"></a><strong>不同的reactor如何去实现</strong></h3><table>
<thead>
<tr>
<th>Reactor 单线程模式</th>
<th>EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup(1); ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap(); serverBootstrap.group(eventGroup);</th>
</tr>
</thead>
<tbody><tr>
<td>非主从 Reactor 多线程模式</td>
<td>EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup(); ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap(); serverBootstrap.group(eventGroup); &#x2F;&#x2F;默认根据cpu的核心数进行new线程。</td>
</tr>
<tr>
<td>主从 Reactor 多线程模式</td>
<td>EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(); EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup(); ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup);</td>
</tr>
</tbody></table>
<h2 id="3-netty对reactor的常见疑问"><a href="#3-netty对reactor的常见疑问" class="headerlink" title="3.netty对reactor的常见疑问"></a><strong>3.netty对reactor的常见疑问</strong></h2><h3 id="3-1-Netty-如何支持主从-Reactor-模式的？"><a href="#3-1-Netty-如何支持主从-Reactor-模式的？" class="headerlink" title="3.1 Netty 如何支持主从 Reactor 模式的？"></a><strong>3.1 Netty 如何支持主从 Reactor 模式的？</strong></h3><p>在EchoServer中，bossGroup就是main reactor。 workerGroup就是sub Reactor。</p>
<p><img src="https://pic2.zhimg.com/80/v2-af2d850c62d844f90c87ab40c4f088f5_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>serverSocketChannel绑定到bossGroup中，那么serverSocketChannel就会创建childChannel并且绑定到workerGroup中。把两种socketchanner绑定到两个不同的group中，用于支持主从reactor模式。</p>
<h3 id="3-2-为什么说-Netty-的-main-reactor-大多并不能用到一个线程组，只能线程组里面的一个？"><a href="#3-2-为什么说-Netty-的-main-reactor-大多并不能用到一个线程组，只能线程组里面的一个？" class="headerlink" title="3.2 为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个？"></a><strong>3.2 为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个？</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-11d4193a99916879a4bb46aa7de1ef78_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>io.netty.bootstrap.AbstractBootstrap#doBind（）方法里面初始化bossgroup，doBind()方法绑定一个地址和端口，把服务器给启动起来。对于服务器来说，我们一般只会绑定一个地址和一个端口，所以我们只会调用一次线程组的线程。</p>
<h3 id="3-3-Netty-给-Channel-分配-NIO-event-loop-的规则是什么"><a href="#3-3-Netty-给-Channel-分配-NIO-event-loop-的规则是什么" class="headerlink" title="3.3 Netty 给 Channel 分配 NIO event loop 的规则是什么"></a><strong>3.3 Netty 给 Channel 分配 NIO event loop 的规则是什么</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel) <br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel)</span> &#123;<br>        <span class="hljs-keyword">return</span> next().register(channel);<br>    &#125;<br><br><span class="hljs-comment">//根据待绑定的executor是否是2的幂次方，做出不同的选择</span><br>io.netty.util.concurrent.DefaultEventExecutorChooserFactory#newChooser<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutorChooser <span class="hljs-title function_">newChooser</span><span class="hljs-params">(EventExecutor[] executors)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isPowerOfTwo(executors.length)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span>(executors);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericEventExecutorChooser</span>(executors);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如果是2的幂次方，会有一个内部类，实现一个取模运算提升效率。</p>
<p>注意：这里的下标要保证线程安全，所以使用AtomicInteger的自增。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<br><br>    PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;<br>        <span class="hljs-built_in">this</span>.executors = executors;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//executors总数必须是2的幂次方（2，4，8...等）才会用,&amp;运算效率更高,同时当idx累加成最大值之后，相比较通用的方式（GenericEventExecutorChooser），更公平</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果不是二的倍数，使用默认方法，递增-&gt;取模-&gt;取绝对值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<br><br>    GenericEventExecutorChooser(EventExecutor[] executors) &#123;<br>        <span class="hljs-built_in">this</span>.executors = executors;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//递增、取模，取正值，不然可能是负数，另外：有个非常小的缺点，当idx累加成最大值后，有短暂的不公平：</span><br>        <span class="hljs-comment">//1，2，3，4，5，6，7，0，7（注意这里不是1，而是7，然而往前的第二个也是7，所以不够公平），6，5</span><br>        <span class="hljs-keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-4-通用模式的-NIO-实现多路复用器是怎么跨平台的"><a href="#3-4-通用模式的-NIO-实现多路复用器是怎么跨平台的" class="headerlink" title="3.4 通用模式的 NIO 实现多路复用器是怎么跨平台的"></a><strong>3.4 通用模式的 NIO 实现多路复用器是怎么跨平台的</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.channel.nio.NioEventLoopGroup#NioEventLoopGroup(<span class="hljs-type">int</span>, java.util.concurrent.Executor)   <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor)</span> &#123;<br>        <span class="hljs-comment">//默认selector,最终实现类似：https://github.com/frohoff/jdk8u-jdk/blob/master/src/macosx/classes/sun/nio/ch/DefaultSelectorProvider.java</span><br>        <span class="hljs-comment">//basic flow: 1 java.nio.channels.spi.SelectorProvider 2 META-INF/services 3 default</span><br>        <span class="hljs-built_in">this</span>(nThreads, executor, SelectorProvider.provider());<br>    &#125;<br><br>java.nio.channels.spi.SelectorProvider#provider<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SelectorProvider <span class="hljs-title function_">provider</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">if</span> (provider != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> provider;<br>            <span class="hljs-keyword">return</span> AccessController.doPrivileged(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;SelectorProvider&gt;() &#123;<br>                    <span class="hljs-keyword">public</span> SelectorProvider <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                           ........<br>                            provider = sun.nio.ch.DefaultSelectorProvider.create(); <span class="hljs-comment">//调用不同平台下的创建方法进行创建</span><br>                            <span class="hljs-keyword">return</span> provider;<br>                        &#125;<br>                    &#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SelectorProvider <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KQueueSelectorProvider</span>();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-TCP粘包、半包"><a href="#4-TCP粘包、半包" class="headerlink" title="4.TCP粘包、半包"></a><strong>4.TCP粘包、半包</strong></h2><h3 id="什么是粘包和半包？"><a href="#什么是粘包和半包？" class="headerlink" title="什么是粘包和半包？"></a><strong>什么是粘包和半包？</strong></h3><p>abc \n def -&gt; a bcd\nef</p>
<p>想要发送的是两段信息分别是abc和def中间由\n分隔。在传输过后，先接受到a，再接收到bcd\nef。那么先接收到的a就是半包（没接收完整），后面接收到的 “bcd \n ef”，就是粘包。</p>
<h3 id="为什么TCP应用中会出现粘包和半包现象？"><a href="#为什么TCP应用中会出现粘包和半包现象？" class="headerlink" title="为什么TCP应用中会出现粘包和半包现象？"></a><strong>为什么TCP应用中会出现粘包和半包现象？</strong></h3><h3 id="粘包的主要原因："><a href="#粘包的主要原因：" class="headerlink" title="粘包的主要原因："></a><strong>粘包的主要原因：</strong></h3><ul>
<li>发送方每次写入数据 &lt; 套接字缓冲区大小</li>
<li>接收方读取套接字缓冲区不够及时</li>
</ul>
<h3 id="半包："><a href="#半包：" class="headerlink" title="半包："></a><strong>半包：</strong></h3><ul>
<li>发送方写入数据 &gt; 套接字缓冲区大小</li>
<li>发送的数据大于协议的MTU（最大传输单元），必须拆包</li>
</ul>
<h3 id="从收发传输的角度看："><a href="#从收发传输的角度看：" class="headerlink" title="从收发传输的角度看："></a><strong>从收发传输的角度看：</strong></h3><ul>
<li>一个发送可能被多次接收，多个发送可能被一次接收（缓冲区）</li>
<li>一个发送占用了多个传输包，多个发送可能占用一个传输包</li>
</ul>
<p><strong>问题的根本原因：TCP没有消息边界</strong></p>
<h3 id="解决沾包和半包问题的几种常用方法"><a href="#解决沾包和半包问题的几种常用方法" class="headerlink" title="解决沾包和半包问题的几种常用方法"></a><strong>解决沾包和半包问题的几种常用方法</strong></h3><p><strong>解决手段：找出消息边界</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-92af5693be90621266c531186492a22b_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="Netty对三种常用封帧方式的支持"><a href="#Netty对三种常用封帧方式的支持" class="headerlink" title="Netty对三种常用封帧方式的支持"></a><strong>Netty对三种常用封帧方式的支持</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-1576feaecc2bfe3cadb44432d0d3c639_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="解读Netty处理粘包、半包的源码"><a href="#解读Netty处理粘包、半包的源码" class="headerlink" title="解读Netty处理粘包、半包的源码"></a><strong>解读Netty处理粘包、半包的源码</strong></h2><h3 id="解码核心工作流程"><a href="#解码核心工作流程" class="headerlink" title="解码核心工作流程"></a><strong>解码核心工作流程</strong></h3><p>解码入口方法：io.netty.handler.codec.ByteToMessageDecoder#channelRead</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//参数msg就是传入的数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ByteBuf) &#123;<br>        <span class="hljs-type">CodecOutputList</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> CodecOutputList.newInstance();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//要解析的数据首先转化为data</span><br>            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>            first = cumulation == <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//如果是第一笔数据，就赋值给cumulation数据积累器，也就是在解码前或者解码后都是一个数据积累的过程</span><br>            <span class="hljs-keyword">if</span> (first) &#123;<br>                cumulation = data;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果不是第一笔数据，就追加到cumulation，采用的是策略模式</span><br>                cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);<br>            &#125;<br>            callDecode(ctx, cumulation, out);<br>        &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (cumulation != <span class="hljs-literal">null</span> &amp;&amp; !cumulation.isReadable()) &#123;<br>                numReads = <span class="hljs-number">0</span>;<br>                cumulation.release();<br>                cumulation = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++ numReads &gt;= discardAfterReads) &#123;<br>                <span class="hljs-comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/4275</span><br>                numReads = <span class="hljs-number">0</span>;<br>                discardSomeReadBytes();<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> out.size();<br>            decodeWasNull = !out.insertSinceRecycled();<br>            fireChannelRead(ctx, out, size);<br>            out.recycle();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ctx.fireChannelRead(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>参数msg就是传入的数据,要解析的数据首先转化为data. 如果是第一笔数据，就赋值给cumulation数据积累器，也就是在解码前或者解码后都是一个数据积累的过程;如果不是第一笔数据，就追加到cumulation，采用的是策略模式。 接着调用callDecode解码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callDecode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//参数in就是数据积累器的数据</span><br>        <span class="hljs-keyword">while</span> (in.isReadable()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">outSize</span> <span class="hljs-operator">=</span> out.size();<br><br>            <span class="hljs-keyword">if</span> (outSize &gt; <span class="hljs-number">0</span>) &#123;<br>                fireChannelRead(ctx, out, outSize);<br>                out.clear();<br><br>                <span class="hljs-comment">// Check if this handler was removed before continuing with decoding.</span><br>                <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See:</span><br>                <span class="hljs-comment">// - https://github.com/netty/netty/issues/4635</span><br>                <span class="hljs-keyword">if</span> (ctx.isRemoved()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                outSize = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">oldInputLength</span> <span class="hljs-operator">=</span> in.readableBytes();<br>            decodeRemovalReentryProtection(ctx, in, out);<br><br>            <span class="hljs-comment">// Check if this handler was removed before continuing the loop.</span><br>            <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/1664</span><br>            <span class="hljs-keyword">if</span> (ctx.isRemoved()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (outSize == out.size()) &#123;<br>                <span class="hljs-keyword">if</span> (oldInputLength == in.readableBytes()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (oldInputLength == in.readableBytes()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(<br>                        StringUtil.simpleClassName(getClass()) +<br>                                <span class="hljs-string">&quot;.decode() did not read anything but decoded a message.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (isSingleDecode()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception cause) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>参数in就是数据积累器的数据，也就是我们收到的数据，第一次outSize大小肯定为0，所以跳过if语句，然后会调用decodeRemovalReentryProtection（）方法。该方法作用是：在decode中时，是不能执行handler remove清理操作的，在decode完之后需要清理数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decodeRemovalReentryProtection</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    decodeState = STATE_CALLING_CHILD_DECODE;<br>    <span class="hljs-keyword">try</span> &#123;<br>        decode(ctx, in, out);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removePending</span> <span class="hljs-operator">=</span> decodeState == STATE_HANDLER_REMOVED_PENDING;<br>        decodeState = STATE_INIT;<br>        <span class="hljs-keyword">if</span> (removePending) &#123;<br>            handlerRemoved(ctx);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>内部会调用decode方法，该方法采用的是模版方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception;<br></code></pre></td></tr></table></figure>

<p>可以查询子类FixedLengthFrameDecoder，此时就完成一次数据解析的流程。 通过下面的代码就可以发现，处理了粘包和半包的问题。 在编码数据前，先对数据进行积累Cumulator。解码的时候先判断是否小于固定的长度，小的话就是包不全也就不去解码数据，等于的话就直接解(没问题)，大于的话就解对应长度的，多的那部分还是在积累器里面，等下次用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">decode</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@SuppressWarnings(&quot;UnusedParameters&quot;)</span> ChannelHandlerContext ctx, ByteBuf in)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (in.readableBytes() &lt; frameLength) &#123;<span class="hljs-comment">//处理半包的问题</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//处理粘包的问题，多余的数据还会存储在accumation中</span><br>        <span class="hljs-keyword">return</span> in.readRetainedSlice(frameLength);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解码中两种数据积累器的区别"><a href="#解码中两种数据积累器的区别" class="headerlink" title="解码中两种数据积累器的区别"></a><strong>解码中两种数据积累器的区别</strong></h3><h3 id="MERGE-CUMULATOR"><a href="#MERGE-CUMULATOR" class="headerlink" title="MERGE_CUMULATOR"></a><strong>MERGE_CUMULATOR</strong></h3><p>using memory copies</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Cumulator</span> <span class="hljs-variable">MERGE_CUMULATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cumulator</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">cumulate</span><span class="hljs-params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> &#123;<br>        <span class="hljs-keyword">final</span> ByteBuf buffer;<br>        <span class="hljs-comment">//如果容量不够就扩容</span><br>        <span class="hljs-keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()<br>                || cumulation.refCnt() &gt; <span class="hljs-number">1</span> || cumulation.isReadOnly()) &#123;<br>            <span class="hljs-comment">// Expand cumulation (by replace it) when either there is not more room in the buffer</span><br>            <span class="hljs-comment">// or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</span><br>            <span class="hljs-comment">// duplicate().retain() or if its read-only.</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See:</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/2327</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/1764</span><br>            buffer = expandCumulation(alloc, cumulation, in.readableBytes());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            buffer = cumulation;<br>        &#125;<br>        <span class="hljs-comment">//如果容量足够的话，就直接把数据追加进去</span><br>        buffer.writeBytes(in);<br>        in.release();<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="COMPOSITE-CUMULATOR"><a href="#COMPOSITE-CUMULATOR" class="headerlink" title="COMPOSITE_CUMULATOR"></a><strong>COMPOSITE_CUMULATOR</strong></h3><ul>
<li>ByteBuf通过将它们添加到 CompositeByteBuf 来累积，因此尽可能不复制内存。请注意，使用更复杂的索引实现，CompositeByteBuf因此根据您的用例和解码器实现，这可能会更慢，然后只使用 MERGE_CUMULATOR。</li>
<li>不是真正的复制，而是提供一个逻辑的视图，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Cumulator</span> <span class="hljs-variable">COMPOSITE_CUMULATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cumulator</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">cumulate</span><span class="hljs-params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> &#123;<br>        ByteBuf buffer;<br>        <span class="hljs-keyword">if</span> (cumulation.refCnt() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the user</span><br>            <span class="hljs-comment">// use slice().retain() or duplicate().retain().</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See:</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/2327</span><br>            <span class="hljs-comment">// - https://github.com/netty/netty/issues/1764</span><br>            buffer = expandCumulation(alloc, cumulation, in.readableBytes());<br>            buffer.writeBytes(in);<br>            in.release();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            CompositeByteBuf composite;<br>            <span class="hljs-comment">//创建compositeByteBuf</span><br>            <span class="hljs-keyword">if</span> (cumulation <span class="hljs-keyword">instanceof</span> CompositeByteBuf) &#123;<br>                composite = (CompositeByteBuf) cumulation;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                composite = alloc.compositeBuffer(Integer.MAX_VALUE);<br>                composite.addComponent(<span class="hljs-literal">true</span>, cumulation);<br>            &#125;<br>            <span class="hljs-comment">//避免内存复制</span><br>            composite.addComponent(<span class="hljs-literal">true</span>, in);<br>            buffer = composite;<br>        &#125;<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>MERGE_CUMULATOR是通过copy实现，实际操作的是ByteBuf；COMPOSITE_CUMULATOR操作的CompositeByteBuf可以看做是对ByteBuf的封装，其维护了一个ByteBuf的List列表，每次cumulate操作其实把当前的ByteBuf放到List中。</p>
<p>我认为这两种cumulate的性能侧重点不同，merge方式提前copy，那么读取时会更快，反之，使用composite的方式在读取时需要遍历List，读取数据时更慢。</p>
<p>我觉得使用哪种数据累计器主要看decode实现，如果decode的实现包含很多随机读（比如读取第4-8个字节这种），这种情况肯定是基于复制的Cumulator更好，因为复制方式是连续内存，随机读时间复杂度为O(1), 而组合方式是基于数组实现，由于不确定目标内容在数组的位置，所以 需要遍历数组，效率偏低。</p>
<h3 id="数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？"><a href="#数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？" class="headerlink" title="数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？"></a><strong>数据收集器有两种方式，一种内存复制，一种组合方式，这两种方式netty选择内存复制作为默认方式？</strong></h3><p>因为组合的方式没有经过充分的证明：证明在所有场景下肯定比内存复制的性能要好（毕竟组合方式的指针维护复杂些，如果解码是把组合的直接能拆出来就可以用，那明显会好，例如ssl hanlder里面就有显示设置为组合方式的例子，但是大多不是如此用，仅有的测试也只是表明好一点点而已)，所以自然默认就还是用原始的那种方式，而不是直接切换到后来加的组合方式，另外提供了setCumulator方法让我们有切换的选择。 总结下：不是说1+1不等于2，而是说大家都这么觉得，但是没有人去有力的证明，所以保持怀疑的态度，就保守起见了，没有改默认的。</p>
<h3 id="三种解码器的常用额外控制参数有哪些"><a href="#三种解码器的常用额外控制参数有哪些" class="headerlink" title="三种解码器的常用额外控制参数有哪些"></a><strong>三种解码器的常用额外控制参数有哪些</strong></h3><table>
<thead>
<tr>
<th>解码器</th>
<th>变量</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>FixedLengthFrameDecoder（固定长度解码器）</td>
<td>frameLength：指定固定的消息长度。 maxFrameLength：可选参数，用于限制解码的帧的最大长度。 lengthFieldOffset、lengthFieldLength、lengthAdjustment、initialBytesToStrip：这些参数用于处理消息中的长度字段，通常用于半包处理。</td>
<td>支持多种分隔符</td>
</tr>
<tr>
<td>DelimiterBasedFrameDecoder（分隔符解码器）</td>
<td>maxFrameLength：指定解码的帧的最大长度。 stripDelimiter：指定是否从解码的帧中删除分隔符。 failFast：可选参数，用于控制是否快速失败（即在遇到无效分隔符时立即抛出异常）。</td>
<td>指定长度</td>
</tr>
<tr>
<td>LengthFieldBasedFrameDecoder（长度字段解码器）</td>
<td>maxFrameLength：帧的最大长度，超过此长度将抛出 TooLongFrameException异常。 lengthFieldOffset：长度字段的偏移量。 lengthFieldLength：长度字段的长度。 lengthAdjustment：长度字段的补偿值，用于调整帧的长度。 initialBytesToStrip：从解码帧中跳过的前几个字节的数量。 failFast：如果为 true，当解码器注意到帧的长度将超过 maxFrameLength 时立即抛出 TooLongFrameException 异常；如果为 false，在完全读取超过 maxFrameLength 的帧后再抛出异常。</td>
<td>根据消息中长度字段的值动态拆分接收到的ByteBuf</td>
</tr>
</tbody></table>
<h2 id="5-常用的“二次”编解码方式"><a href="#5-常用的“二次”编解码方式" class="headerlink" title="5.常用的“二次”编解码方式"></a><strong>5.常用的“二次”编解码方式</strong></h2><h3 id="为什么需要二次解码"><a href="#为什么需要二次解码" class="headerlink" title="为什么需要二次解码"></a><strong>为什么需要二次解码</strong></h3><ul>
<li><p>一次解码器：ByteToMessageDecoder</p>
</li>
<li><ul>
<li>io.netty.buffer.ByteBuf （原始数据流）-&gt; io.netty.buffer.ByteBuf （用户数据）</li>
</ul>
</li>
<li><p>二次解码器：MessageToMessageDecoder</p>
</li>
<li><ul>
<li>io.netty.buffer.ByteBuf （用户数据）-&gt; Java Object</li>
</ul>
</li>
</ul>
<p>为了分层和降低耦合性，不建议将两次解码合并成一次。</p>
<h3 id="常用的二次编解码方式"><a href="#常用的二次编解码方式" class="headerlink" title="常用的二次编解码方式"></a><strong>常用的二次编解码方式</strong></h3><p>Java序列号、XML、JSON、Protobuf、MessagePack</p>
<h3 id="选择编解码方式的要点"><a href="#选择编解码方式的要点" class="headerlink" title="选择编解码方式的要点"></a><strong>选择编解码方式的要点</strong></h3><ol>
<li>编码后的占用空间大小</li>
<li>编解码速度</li>
<li>可读性</li>
<li>多语言支持</li>
</ol>
<h3 id="Protobuf简介与使用"><a href="#Protobuf简介与使用" class="headerlink" title="Protobuf简介与使用"></a><strong>Protobuf简介与使用</strong></h3><ul>
<li>Protobuf 是一个灵活的、高效的用于序列化数据的协议</li>
<li>相比较 XML 和 JSON 格式，Protobuf 更小、更快、更便捷。</li>
<li>Protobuf 是跨语言的，并且自带了一个编译器（protoc），只需要用它进行编译，可 以自动生成 Java、python、C++ 等代码，不需要再写其他代码</li>
</ul>
<h2 id="Netty对二次编解码的支持"><a href="#Netty对二次编解码的支持" class="headerlink" title="Netty对二次编解码的支持"></a><strong>Netty对二次编解码的支持</strong></h2><p>以WorldClockClientInitializer中的initChannel方法为例，说明netty是如何进行二次编解码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.example.worldclock.WorldClockClientInitializer<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>    <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ch.pipeline();<br>    <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//添加一个 SSL 处理器到管道中，用于处理安全连接</span><br>        p.addLast(sslCtx.newHandler(ch.alloc(), WorldClockClient.HOST, WorldClockClient.PORT));<br>    &#125;<br><br>    <span class="hljs-comment">//一次解码 得到一个bytebuf</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufVarint32FrameDecoder</span>());<br>    <span class="hljs-comment">//二次解码 得到一个object</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufDecoder</span>(WorldClockProtocol.LocalTimes.getDefaultInstance()));<br><br>    <span class="hljs-comment">//一次编码 解决粘包和半包问题</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufVarint32LengthFieldPrepender</span>());<br>    <span class="hljs-comment">//二次编码 字节数组</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufEncoder</span>());<br><br>    <span class="hljs-comment">//业务流程</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WorldClockClientHandler</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="一次解码"><a href="#一次解码" class="headerlink" title="一次解码"></a><strong>一次解码</strong></h3><ul>
<li>第一次解码：<strong>ProtobufVarint32FrameDecoder</strong> 目的是将具体内容拆分出来，得到一个bytebuf</li>
</ul>
<p>Varint &#x3D; 长度字段的长度可变： 值越小的数字使用越少的字节数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">BEFORE <span class="hljs-title function_">DECODE</span> <span class="hljs-params">(<span class="hljs-number">302</span> bytes)</span>       AFTER <span class="hljs-title function_">DECODE</span> <span class="hljs-params">(<span class="hljs-number">300</span> bytes)</span><br>+--------+---------------+      +---------------+<br>| Length | Protobuf Data |-----&gt;| Protobuf Data |<br>| <span class="hljs-number">0xAC02</span> |  (<span class="hljs-number">300</span> bytes)  |      |  (<span class="hljs-number">300</span> bytes)  |<br>+--------+---------------+      +---------------+<br></code></pre></td></tr></table></figure>

<h3 id="二次解码"><a href="#二次解码" class="headerlink" title="二次解码"></a><strong>二次解码</strong></h3><ul>
<li>第二次解码：<strong>ProtobufDecoder</strong> 目的是对protobuf中的信息进行具体的处理，得到一个java object<br>在decode方法中，会对传入的bytebuf进行不同情况的处理，先判断是否有extension再判断是否存在HAS_PARSER。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] array;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> offset;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> msg.readableBytes();<br>    <span class="hljs-keyword">if</span> (msg.hasArray()) &#123;<br>        array = msg.array();<br>        offset = msg.arrayOffset() + msg.readerIndex();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        array = ByteBufUtil.getBytes(msg, msg.readerIndex(), length, <span class="hljs-literal">false</span>);<br>        offset = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//带extension 扩展</span><br>    <span class="hljs-keyword">if</span> (extensionRegistry == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//HAS_PARSER when &gt;protobuf 2.5.0</span><br>        <span class="hljs-keyword">if</span> (HAS_PARSER) &#123;<br>            out.add(prototype.getParserForType().parseFrom(array, offset, length));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            out.add(prototype.newBuilderForType().mergeFrom(array, offset, length).build());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (HAS_PARSER) &#123;<br>            out.add(prototype.getParserForType().parseFrom(<br>                    array, offset, length, extensionRegistry));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            out.add(prototype.newBuilderForType().mergeFrom(<br>                    array, offset, length, extensionRegistry).build());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="一次编码"><a href="#一次编码" class="headerlink" title="一次编码"></a><strong>一次编码</strong></h3><ul>
<li>第一次编码：<strong>ProtobufVarint32LengthFieldPrepender</strong>，解决粘包和半包问题。在编码的头部加入length字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">BEFORE <span class="hljs-title function_">ENCODE</span> <span class="hljs-params">(<span class="hljs-number">300</span> bytes)</span>       AFTER <span class="hljs-title function_">ENCODE</span> <span class="hljs-params">(<span class="hljs-number">302</span> bytes)</span><br>+---------------+               +--------+---------------+<br>| Protobuf Data |--------------&gt;| Length | Protobuf Data |<br>|  (<span class="hljs-number">300</span> bytes)  |               | <span class="hljs-number">0xAC02</span> |  (<span class="hljs-number">300</span> bytes)  |<br>+---------------+               +--------+---------------+<br></code></pre></td></tr></table></figure>

<p>为了实现高性能，还会对不同长度的length进行位运算，以达到使用最少的字节数表达长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">computeRawVarint32Size</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-comment">//根据不同的值返回不同的字节数</span><br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt;  <span class="hljs-number">7</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">14</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">21</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((value &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">28</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二次编码"><a href="#二次编码" class="headerlink" title="二次编码"></a><strong>二次编码</strong></h3><ul>
<li>第二次编码：<strong>ProtobufEncoder</strong> 得到一个字节数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageLiteOrBuilder msg, List&lt;Object&gt; out)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> MessageLite) &#123;<br>        out.add(wrappedBuffer(((MessageLite) msg).toByteArray()));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> MessageLite.Builder) &#123;<br>        out.add(wrappedBuffer(((MessageLite.Builder) msg).build().toByteArray()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-Keepalive与idle监测"><a href="#6-Keepalive与idle监测" class="headerlink" title="6.Keepalive与idle监测"></a><strong>6.Keepalive与idle监测</strong></h2><h3 id="为什么要keepalive"><a href="#为什么要keepalive" class="headerlink" title="为什么要keepalive"></a><strong>为什么要keepalive</strong></h3><p>在双方进行通话时，如何对方不讲话了，我们需要问一句“你还在吗？”如果对方没有回复，挂机。这套机制就是keepalive。</p>
<p><img src="https://pic4.zhimg.com/80/v2-478dfdbf49fb7236f1eed3c3e8c4034f_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="怎么设计keepalive？以TCP-keepalive为例"><a href="#怎么设计keepalive？以TCP-keepalive为例" class="headerlink" title="怎么设计keepalive？以TCP keepalive为例"></a><strong>怎么设计keepalive？以TCP keepalive为例</strong></h3><p>TCP keepalive核心参数：</p>
<blockquote>
<p>net.ipv4.tcp_keepalive_time &#x3D; 7200 &#x2F;&#x2F;出现问题概率小，没有必要频繁<br>net.ipv4.tcp_keepalive_intvl &#x3D; 75<br>net.ipv4.tcp_keepalive_probes &#x3D; 9 &#x2F;&#x2F;谨慎判断</p>
</blockquote>
<p>当启用（默认关闭）keepalive时，TCP在没有数据通过的7200秒后发送keepalive消息，当探测没有确认时，按75秒的重试评论重发，一直法9个探测包都没有确认，就认为连接失败，则关闭连接。</p>
<p>总耗时 7200+75*9 &#x3D; 2h 11min</p>
<h3 id="为什么还需要应用层keepalive"><a href="#为什么还需要应用层keepalive" class="headerlink" title="为什么还需要应用层keepalive"></a><strong>为什么还需要应用层keepalive</strong></h3><ul>
<li>TCP层的keepalive默认关闭 ，而且经过路由等中转设备可能会被丢弃。</li>
<li>keepalive时间太长（默认&gt;2h），虽然可以改，但是必须要改动所有应用</li>
<li>各层协议关注点不同。传输层关注是否连接通常，应用层关注是否可服务。电话通了并不代表有人接。</li>
</ul>
<p>应用层的keepalive长连接在HTTP1里面有header。HTTP&#x2F;1.1默认是长连接，所以没有这个header</p>
<h3 id="Idle监测是什么"><a href="#Idle监测是什么" class="headerlink" title="Idle监测是什么"></a><strong>Idle监测是什么</strong></h3><p>在通话场景中，如果对方突然不说话了。那么我们会稍微等待一段时间，看看这个时间内对方还会不会说话（idle），如何还不说，就认为对方存在问题（idle），于是开始发问“你还在吗”（keepalive），或者直接挂机（关闭连接）。</p>
<ul>
<li><p>Idle监测只是负责诊断，做出不同的行为后，觉得Idle的最终用途。</p>
</li>
<li><p>发送keepalive：<br><strong>keepalive演进</strong></p>
</li>
<li><ul>
<li>v1：定时发送消息（消耗太大）</li>
<li>v2：有其他数据传输（业务），不发送keepalive。没有数据传输，判定为Idle,再发送keepalive。</li>
</ul>
</li>
<li><p>直接关闭连接</p>
</li>
<li><ul>
<li>快速释放损坏，恶意、不使用的连接</li>
<li>客户端重连。</li>
</ul>
</li>
</ul>
<h3 id="如何在Netty中开启TCP-keepalive和Idle监测"><a href="#如何在Netty中开启TCP-keepalive和Idle监测" class="headerlink" title="如何在Netty中开启TCP keepalive和Idle监测"></a><strong>如何在Netty中开启TCP keepalive和Idle监测</strong></h3><h3 id="开启两种风格的keepalive"><a href="#开启两种风格的keepalive" class="headerlink" title="开启两种风格的keepalive"></a><strong>开启两种风格的keepalive</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">.childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>.childOption(NioChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure>

<p>提示：.option(ChannelOption.SO_KEEPALIVE,true) 存在但是无效</p>
<h3 id="开启不同的Idle-Check："><a href="#开启不同的Idle-Check：" class="headerlink" title="开启不同的Idle Check："></a><strong>开启不同的Idle Check：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(“idleCheckHandler<span class="hljs-string">&quot;, new IdleStateHandler(0, 20, 0, TimeUnit.SECONDS));</span><br><span class="hljs-string">//----------------------//</span><br><span class="hljs-string">public IdleStateHandler(</span><br><span class="hljs-string">        long readerIdleTime, long writerIdleTime, long allIdleTime,</span><br><span class="hljs-string">        TimeUnit unit) &#123;</span><br><span class="hljs-string">    this(false, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="源码解读Netty对TCP-keepalive和三种Idle监测的支持"><a href="#源码解读Netty对TCP-keepalive和三种Idle监测的支持" class="headerlink" title="源码解读Netty对TCP keepalive和三种Idle监测的支持"></a><strong>源码解读Netty对TCP keepalive和三种Idle监测的支持</strong></h2><h3 id="设置TCP-keepalive怎么生效"><a href="#设置TCP-keepalive怎么生效" class="headerlink" title="设置TCP keepalive怎么生效"></a><strong>设置TCP keepalive怎么生效</strong></h3><p>以EchoServer为例，从设置keepalive的childOption方法进入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. io.netty.bootstrap.ServerBootstrap<span class="hljs-comment">#childOption  </span><br>2.   -&gt; io.netty.bootstrap.ServerBootstrap<span class="hljs-comment">#init  </span><br>3.      -&gt; io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor<span class="hljs-comment">#ServerBootstrapAcceptor  </span><br>4.         -&gt; io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor<span class="hljs-comment">#channelRead</span><br>5.            -&gt; io.netty.bootstrap.AbstractBootstrap<span class="hljs-comment">#setChannelOptions  </span><br>6.              -&gt;io.netty.bootstrap.AbstractBootstrap<span class="hljs-comment">#setChannelOption  </span><br>7.                -&gt; io.netty.channel.socket.nio.NioSocketChannel.NioSocketChannelConfig<span class="hljs-comment">#setOption</span><br></code></pre></td></tr></table></figure>

<p>1.传入一个普通的channel而不是传入一个serverSocketChannel，在childOption()方法中，对成员变量childOptions进行了设置，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;ChannelOption&lt;?&gt;, Object&gt;();<br></code></pre></td></tr></table></figure>

<p>2.成员变量childOptions在init()方法中被转化为currentChildOptions。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>

<p>ChannelInitializer一次性、初始化handler: 负责添加一个ServerBootstrapAcceptor handler，添加完后，自己就移除了: ServerBootstrapAcceptor handler： 负责接收客户端连接创建连接后，对连接的初始化工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.bootstrap.ServerBootstrap#init <br>    <br>p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>        <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>        <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>            pipeline.addLast(handler);<br>        &#125;<br><br>        ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>3.io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#ServerBootstrapAcceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerBootstrapAcceptor(<span class="hljs-comment">//接受连接后的后续处理</span><br>......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4.对于上面的ServerBootstrapAcceptor的后续处理由channelRead()方法进行处理。<strong>将childOption设置到Channel里面去</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (Channel) msg;  <span class="hljs-comment">//msg是一个channel</span><br>    child.pipeline().addLast(childHandler);<br>    setChannelOptions(child, childOptions, logger); <span class="hljs-comment">//设置childOption</span><br>    setAttributes(child, childAttrs);<br>        ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5.io.netty.bootstrap.AbstractBootstrap#setChannelOptions<br>static void setChannelOptions<br>setChannelOption(channel, e.getKey(), e.getValue(), logger);</p>
<p>6 -&gt; 7.</p>
<p>7.直到第七步可以看见接口有许多实现类，选择NioSocketChannel，可以看见由nio方式实现的设置keepalive方法。同时，在DefaultChannelConfig中实现了另一种设置keepalive的方式。</p>
<h3 id="两种设置keepalive的方式有什么区别？"><a href="#两种设置keepalive的方式有什么区别？" class="headerlink" title="两种设置keepalive的方式有什么区别？"></a><strong>两种设置keepalive的方式有什么区别？</strong></h3><ul>
<li><strong>io.netty.channel.socket.nio.NioSocketChannel</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置指定的选项到指定的 JDK 原生 Channel。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> jdkChannel JDK 原生 Channel</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> option     NioChannelOption 选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value      选项值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;        选项类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果设置成功，则返回 true；否则返回 false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">setOption</span><span class="hljs-params">(Channel jdkChannel, NioChannelOption&lt;T&gt; option, T value)</span> &#123;<br>    <span class="hljs-comment">// 将 JDK 原生 Channel 转换为 NetworkChannel 类型</span><br>    java.nio.channels.<span class="hljs-type">NetworkChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (java.nio.channels.NetworkChannel) jdkChannel;<br><br>    <span class="hljs-comment">// 检查通道是否支持指定的选项</span><br>    <span class="hljs-keyword">if</span> (!channel.supportedOptions().contains(option.option)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果是 ServerSocketChannel 并且选项是 IP_TOS，则跳过设置，作为 JDK bug 的解决方法</span><br>    <span class="hljs-keyword">if</span> (channel <span class="hljs-keyword">instanceof</span> ServerSocketChannel &amp;&amp; option.option == java.net.StandardSocketOptions.IP_TOS) &#123;<br>        <span class="hljs-comment">// 跳过 IP_TOS 选项</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 设置选项到 JDK 原生 Channel</span><br>        channel.setOption(option.option, value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-comment">// 发生异常时，抛出 ChannelException</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>io.netty.channel.socket.nio.DefaultChannelConfig</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置通道选项到 Netty Channel。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> option 选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value  选项值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;    选项类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果设置成功，则返回 true；否则返回 false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">setOption</span><span class="hljs-params">(ChannelOption&lt;T&gt; option, T value)</span> &#123;<br>    <span class="hljs-comment">// 验证选项和值是否有效</span><br>    validate(option, value);<br><br>    <span class="hljs-comment">// 根据选项类型执行相应的设置操作</span><br>    <span class="hljs-keyword">if</span> (option == SO_RCVBUF) &#123;<br>        <span class="hljs-comment">// 设置接收缓冲区大小</span><br>        setReceiveBufferSize((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_SNDBUF) &#123;<br>        <span class="hljs-comment">// 设置发送缓冲区大小</span><br>        setSendBufferSize((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == TCP_NODELAY) &#123;<br>        <span class="hljs-comment">// 设置 TCP_NODELAY</span><br>        setTcpNoDelay((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_KEEPALIVE) &#123;<br>        <span class="hljs-comment">// 设置 SO_KEEPALIVE</span><br>        setKeepAlive((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_REUSEADDR) &#123;<br>        <span class="hljs-comment">// 设置 SO_REUSEADDR</span><br>        setReuseAddress((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == SO_LINGER) &#123;<br>        <span class="hljs-comment">// 设置 SO_LINGER</span><br>        setSoLinger((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == IP_TOS) &#123;<br>        <span class="hljs-comment">// 设置 IP_TOS</span><br>        setTrafficClass((Integer) value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option == ALLOW_HALF_CLOSURE) &#123;<br>        <span class="hljs-comment">// 设置 ALLOW_HALF_CLOSURE</span><br>        setAllowHalfClosure((Boolean) value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 调用父类的 setOption() 方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setOption(option, value);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这两个方法分别是<code>Netty</code>框架中的两个不同类中的方法，用于设置通道选项。</p>
<p><code>setOption(Channel jdkChannel, NioChannelOption&lt;T&gt; option, T value)</code>方法是一个静态方法，用于设置指定的选项到指定的<code>JDK</code>原生<code>Channel</code>。</p>
<p><code>setOption(ChannelOption&lt;T&gt; option, T value)</code>方法是<code>Channel</code>类的实例方法，用于设置通道选项到<code>Netty</code>的<code>Channel</code>中。</p>
<p>这两个方法的区别在于，<code>setOption(Channel jdkChannel, NioChannelOption&lt;T&gt; option, T value)</code>方法是用于设置<code>JDK</code>原生<code>Channel</code>的选项，而<code>setOption(ChannelOption&lt;T&gt; option, T value)</code>方法是用于设置<code>Netty</code>的<code>Channel</code>的选项。</p>
<p>从代码可扩展性来看nio中的方法显然更容易添加和修改，而默认方式很多if&#x2F;else的情况下，如果要修改一个，就会牵一发而动全身。</p>
<h3 id="Idle检测类包（io-netty-handler-timeout）的功能有哪些"><a href="#Idle检测类包（io-netty-handler-timeout）的功能有哪些" class="headerlink" title="Idle检测类包（io.netty.handler.timeout）的功能有哪些"></a><strong>Idle检测类包（io.netty.handler.timeout）的功能有哪些</strong></h3><p>位置在handler模块下的timeout包</p>
<p><img src="https://pic3.zhimg.com/80/v2-bdaf9058a99f6b15f44152b9d08d8002_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="三种类型Idle"><a href="#三种类型Idle" class="headerlink" title="三种类型Idle"></a>三种类型Idle</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">public enum IdleState &#123;<br> /**<br> * 当在指定时间段内未执行读取时，将触发状态为IdleState.READER_IDLE的IdleStateEvent 。指定0以禁用<br> */<br> READER_IDLE,<br> /**<br> * 当在指定的时间段内没有执行写入时，将触发状态为IdleState.WRITER_IDLE的IdleStateEvent 。指定0以禁用。<br> */<br> WRITER_IDLE,<br> /**<br> * 状态为IdleState.ALL_IDLE的IdleStateEvent将在指定时间段内未执行读取或写入时触发。指定0以禁用。<br> */<br> ALL_IDLE<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>六个Idle状态，分别为第一次和非第一次</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">public class IdleStateEvent &#123;<br>    public static final IdleStateEvent FIRST_READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, true);<br>    public static final IdleStateEvent READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, false);<br>    public static final IdleStateEvent FIRST_WRITER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.WRITER_IDLE, true);<br>    public static final IdleStateEvent WRITER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.WRITER_IDLE, false);<br>    public static final IdleStateEvent FIRST_ALL_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.ALL_IDLE, true);<br>    public static final IdleStateEvent ALL_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.ALL_IDLE, false);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="读Idle检测的原理"><a href="#读Idle检测的原理" class="headerlink" title="读Idle检测的原理"></a>读Idle检测的原理</h3><p>读取空闲的监测是通过 <code>IdleStateHandler</code> 和事件触发机制实现的。</p>
<blockquote>
<p>用“读”是否超时进行判断</p>
</blockquote>
<p><code>IdleStateHandler</code> 是一个用于检测连接空闲状态的处理器，它会根据指定的时间间隔检查连接的读取空闲状态。它内部使用了 <code>ScheduledExecutorService</code> 来定期检查连接的读取状态。</p>
<p>ReadTimeoutHandler类当在指定时间内没有发生读事件时，抛出异常ReadTimeoutException。在 <code>run()</code> 方法中，首先计算下一个超时的延迟时间 <code>nextDelay</code>。如果当前不是正在读取状态（<code>reading</code> 为 false），则根据当前时间与上次读取时间的差值来调整 <code>nextDelay</code>，以保证超时的准确性。</p>
<p>接下来，通过判断 <code>nextDelay</code> 的值来确定读取是否已经超时。如果 <code>nextDelay</code> 小于等于 0，表示读取已经超时，需要执行相应的操作。首先，重新调度一个新的超时任务，并更新 <code>readerIdleTimeout</code> 变量。然后，根据 <code>firstReaderIdleEvent</code> 的值判断是否为第一次读取空闲事件。如果是第一次，则设置 <code>firstReaderIdleEvent</code> 为 false，否则表示已经发生过读取空闲事件。</p>
<p>接下来，尝试创建一个 <code>IdleStateEvent</code> 实例，表示读取空闲事件，并调用 <code>channelIdle()</code> 方法来通知相关的处理器。如果在这个过程中发生异常，将通过调用 <code>ctx.fireExceptionCaught(t)</code> 来传播异常。</p>
<p>如果 <code>nextDelay</code> 大于 0，表示读取还未超时，需要重新调度一个新的监测任务，使用 <code>nextDelay</code> 作为延迟时间，以便在接下来的时间内继续监测读取空闲状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nextDelay</span> <span class="hljs-operator">=</span> readerIdleTimeNanos;<br>    <span class="hljs-keyword">if</span> (!reading) &#123;<br>        <span class="hljs-comment">//计算是否idle的关键</span><br>        nextDelay -= ticksInNanos() - lastReadTime;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextDelay &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//空闲了</span><br>        <span class="hljs-comment">// Reader is idle - set a new timeout and notify the callback.</span><br>        readerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstReaderIdleEvent;<br>        <span class="hljs-comment">//firstReaderIdleEvent下个读来之前，第一次idle之后，可能触发多次，都属于非第一次idle.</span><br>        firstReaderIdleEvent = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> newIdleStateEvent(IdleState.READER_IDLE, first);<br>            channelIdle(ctx, event);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ctx.fireExceptionCaught(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//重新其一个监测task，用nextdelay时间</span><br>        <span class="hljs-comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span><br>        readerIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="写Idle检测原理和参数observeOutput用途"><a href="#写Idle检测原理和参数observeOutput用途" class="headerlink" title="写Idle检测原理和参数observeOutput用途"></a><strong>写Idle检测原理和参数observeOutput用途</strong></h3><blockquote>
<p>用“写”是否完成进行判断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (timeoutNanos &gt; <span class="hljs-number">0</span>) &#123;<br>        promise = promise.unvoid();<br>        <span class="hljs-comment">//写的时候schedule一个task去检查是否完成了。</span><br>        scheduleTimeout(ctx, promise);<br>    &#125;<br>    ctx.write(msg, promise);<br>&#125;        <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Was not written yet so issue a write timeout</span><br>    <span class="hljs-comment">// The promise itself will be failed with a ClosedChannelException once the close() was issued</span><br>    <span class="hljs-comment">// 判断写是否完成</span><br>    <span class="hljs-keyword">if</span> (!promise.isDone()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeTimedOut(ctx);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ctx.fireExceptionCaught(t);<br>        &#125;<br>    &#125;<br>    removeWriteTimeoutTask(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="observeOutput用途"><a href="#observeOutput用途" class="headerlink" title="observeOutput用途"></a><strong>observeOutput用途</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasOutputChanged</span><span class="hljs-params">(ChannelHandlerContext ctx, <span class="hljs-type">boolean</span> first)</span> &#123;<br>       <span class="hljs-keyword">if</span> (observeOutput) &#123;<br>           <span class="hljs-comment">//正常情况下，false，即写空闲的判断中的写是指写成功，但是实际上，有可能遇到几种情况：</span><br>           <span class="hljs-comment">//（1）写了，但是缓存区满了，写不出去；（2）写了一个大“数据”，写确实在“动”，但是没有完成。</span><br>           <span class="hljs-comment">//所以这个参数，判断是否有“写的意图”，而不是判断“是否写成功”。</span><br>           <span class="hljs-keyword">if</span> (lastChangeCheckTimeStamp != lastWriteTime) &#123;<br>               lastChangeCheckTimeStamp = lastWriteTime;<br><br>               <span class="hljs-comment">// But this applies only if it&#x27;s the non-first call.</span><br>               <span class="hljs-keyword">if</span> (!first) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>           <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> channel.unsafe();<br>           <span class="hljs-type">ChannelOutboundBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> unsafe.outboundBuffer();<br><br>           <span class="hljs-keyword">if</span> (buf != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">messageHashCode</span> <span class="hljs-operator">=</span> System.identityHashCode(buf.current());<br>               <span class="hljs-type">long</span> <span class="hljs-variable">pendingWriteBytes</span> <span class="hljs-operator">=</span> buf.totalPendingWriteBytes();<br>               <span class="hljs-comment">//pendingWriteBytes 不等于上一次的pendingWriteBytes</span><br>               <span class="hljs-keyword">if</span> (messageHashCode != lastMessageHashCode || pendingWriteBytes != lastPendingWriteBytes) &#123;<br>                   lastMessageHashCode = messageHashCode;<br>                   lastPendingWriteBytes = pendingWriteBytes;<br><br>                   <span class="hljs-keyword">if</span> (!first) &#123;<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                   &#125;<br>               &#125;<br><br>               <span class="hljs-type">long</span> <span class="hljs-variable">flushProgress</span> <span class="hljs-operator">=</span> buf.currentProgress();<br>               <span class="hljs-comment">//写进度</span><br>               <span class="hljs-keyword">if</span> (flushProgress != lastFlushProgress) &#123;<br>                   lastFlushProgress = flushProgress;<br><br>                   <span class="hljs-keyword">if</span> (!first) &#123;<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Netty/" class="category-chain-item">Netty</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/" class="category-chain-item">极客时间</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/Netty%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" class="category-chain-item">Netty源码剖析与实战</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Netty/">#Netty</a>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">#极客时间</a>
      
        <a href="/tags/%E6%BA%90%E7%A0%81/">#源码</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>极客时间《netty源码剖析与实战》学习笔记2</div>
      <div>http://muxiang123.github.io/2023/06/21/极客时间《源码剖析与实战》学习笔记2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>HuanKang Zeng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" title="极客时间《netty源码剖析与实战》学习笔记1">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">极客时间《netty源码剖析与实战》学习笔记1</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/21/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/" title="极客时间《netty源码剖析与实战》学习笔记2">
                        <span class="hidden-mobile">极客时间《netty源码剖析与实战》学习笔记2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
